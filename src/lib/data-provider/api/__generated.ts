/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Repairotek API Documentation
 * API documentation for Repairotek project
 * OpenAPI spec version: 1.0.0
 */
import {useMutation, useQuery, useSuspenseQuery} from '@tanstack/react-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
  UseSuspenseQueryOptions,
  UseSuspenseQueryResult,
} from '@tanstack/react-query'
import {axiosInstance} from '../../axios/axios'
import type {ErrorType, BodyType} from '../../axios/axios'
export type PatchProjectBody = {
  areaHeight?: number
  areaLength?: number
  areaWidth?: number
  description?: string
  employees?: string[]
  equipment?: string[]
  latitude?: number
  longitude?: number
  materials?: string[]
  measureUnit?: string
  title?: string
  zoneId?: string
}

export type SignupUser400One = {
  /** Error message */
  error?: string
}

export type SignupUserBody = {
  /** The user's email address */
  email: string
  /** The user's name */
  name: string
  /** The user's password */
  password: string
}

export type Logout500 = {
  /** Error message */
  error?: string
}

export type Logout401 = {
  /** Error message */
  error?: string
}

export type Logout200 = {
  /** Success message */
  message?: string
}

export type RefreshToken404One = {
  /** Error message */
  error?: string
}

export type RefreshToken400One = {
  /** Error message */
  error?: string
}

export type RefreshToken200 = {
  /** JWT access token */
  accessToken?: string
}

export type RefreshTokenBody = {
  /** JWT refresh token */
  refreshToken: string
}

export type LoginUser400One = {
  /** Error message */
  error?: string
}

export type LoginUser200 = {
  /** JWT access token */
  accessToken?: string
  /** Access token expiration time in seconds */
  expiresIn?: number
  /** JWT refresh token */
  refreshToken?: string
  /** Refresh token expiration time in seconds */
  refreshTokenExpiresIn?: number
  /** The logged-in user's details */
  userInfo?: UserInfo
}

export type LoginUserBody = {
  /** The user's email address */
  email: string
  /** The user's password */
  password: string
}

/**
 * The type of the location (Point or Polygon)
 */
export type ZoneLocationType =
  (typeof ZoneLocationType)[keyof typeof ZoneLocationType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ZoneLocationType = {
  Point: 'Point',
  Polygon: 'Polygon',
} as const

export type ZoneLocation = {
  /** The coordinates of the location */
  coordinates: number[][]
  /** The type of the location (Point or Polygon) */
  type: ZoneLocationType
}

export interface Zone {
  /** Accessibility information for the zone */
  accessibility?: string
  /** The size of the zone in square meters */
  areaSize?: number
  /** Timestamp when the Zone was created */
  createdAt?: string
  /** A description of the zone */
  description?: string
  /** Unique identifier for the Zone */
  id?: string
  location: ZoneLocation
  /** The municipal code of the zone */
  municipalCode: string
  /** The name of the zone */
  name: string
  /** The ID of the province */
  provinceId: string
  /** The condition of roads in the zone */
  roadCondition?: string
  /** Array of road IDs referring to roads in the zone */
  roadsId?: string[]
  /** Timestamp when the Zone was last updated */
  updatedAt?: string
}

/**
 * Gender of the user
 */
export type UserGender = (typeof UserGender)[keyof typeof UserGender]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserGender = {
  male: 'male',
  female: 'female',
  other: 'other',
} as const

export interface User {
  /** Address of the user */
  address: string
  /** Timestamp when the user was created */
  createdAt?: string
  /** Email address of the user */
  email: string
  /** First name of the user */
  firstName: string
  /** Gender of the user */
  gender: UserGender
  /** Unique identifier for the user */
  id?: string
  /** Timestamp of the user's last activity (optional) */
  lastActivity?: number
  /** Last name of the user */
  lastName: string
  /** Mobile number of the user */
  mobile: string
  /** National ID of the user (optional) */
  nationalId?: string
  /** Password for the user */
  password: string
  /** List of permission IDs associated with the user */
  permissions?: string[]
  /** URL to the profile photo of the user (optional) */
  profilePhoto?: string
  /** Role ID of the user */
  roleId: string
  /** Telephone number of the user (optional) */
  telephone?: string
  /** Timestamp when the user was last updated */
  updatedAt?: string
}

export interface UserInfo {
  /** Email address of the user */
  email: string
  /** First name of the user */
  firstName: string
  /** Last name of the user */
  lastName: string
  /** URL to the profile photo of the user (optional) */
  profilePhoto?: string
  /** Role of the user */
  role: string
}

export interface TokenBlackList {
  /** Timestamp when the TokenBlackList was created */
  createdAt?: string
  /** Unique identifier for the TokenBlackList */
  id?: string
  /** The token that has been blacklisted */
  token: string
  /** Timestamp when the TokenBlackList was last updated */
  updatedAt?: string
}

export interface TimeCardEmployee {
  /** Actual end time */
  actualEndTime: string
  /** Actual overtime in minutes */
  actualOverTime: number
  /** Actual rest time in minutes */
  actualRestTime: number
  /** Actual start time */
  actualStartTime: string
  /** Timestamp when the TimeCardEmployee was created */
  createdAt?: string
  /** ID of the user who created the record */
  createdBy: string
  /** ID of the employee */
  employeeId: string
  /** Unique identifier for the TimeCardEmployee */
  id?: string
  /** Overtime pay rate */
  overTimePayRate: number
  /** Scheduled end time */
  scheduledEndTime: string
  /** Scheduled overtime in minutes */
  scheduledOverTime: number
  /** Scheduled rest time in minutes */
  scheduledRestTime: number
  /** Scheduled start time */
  scheduledStartTime: string
  /** ID of the related task */
  taskId?: string
  /** Date of the time card */
  timeCardDate: string
  /** Timestamp when the TimeCardEmployee was last updated */
  updatedAt?: string
  /** ID of the user who last updated the record */
  updatedBy: string
  /** Hourly wage rate */
  wageRate: number
}

/**
 * Status of the task
 */
export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TaskStatus = {
  todo: 'todo',
  doing: 'doing',
  done: 'done',
} as const

export type TaskPriority = (typeof TaskPriority)[keyof typeof TaskPriority]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TaskPriority = {
  critical: 'critical',
  'very-high': 'very-high',
  high: 'high',
  medium: 'medium',
  low: 'low',
  'very-low': 'very-low',
} as const

export interface Task {
  /** List of User IDs. */
  assignees?: unknown
  /** Timestamp when the Task was created */
  createdAt?: string
  /** Description of the task */
  description?: string
  dueDate?: string
  /** Unique identifier for the Task */
  id?: string
  priority?: TaskPriority
  /** Status of the task */
  status: TaskStatus
  tags?: unknown
  /** Title of the task */
  title: string
  /** Timestamp when the Task was last updated */
  updatedAt?: string
}

export interface Role {
  /** Timestamp when the Role was created */
  createdAt?: string
  /** Description of the role (optional) */
  description?: string
  /** Unique identifier for the Role */
  id?: string
  /** Name of the role */
  name: string
  /** Timestamp when the Role was last updated */
  updatedAt?: string
}

export interface Road {
  /** The condition of the road */
  condition?: string
  /** Timestamp when the Road was created */
  createdAt?: string
  /** Description of the road */
  description?: string
  /** Unique identifier for the Road */
  id?: string
  /** The length of the road in kilometers */
  length?: number
  /** The name of the road */
  name: string
  /** The type of the road */
  type?: string
  /** Timestamp when the Road was last updated */
  updatedAt?: string
}

export interface Resource {
  /** Timestamp when the Resource was created */
  createdAt?: string
  /** Description of the resource */
  description?: string
  /** Unique identifier for the Resource */
  id?: string
  /** Name of the resource */
  name: string
  /** Timestamp when the Resource was last updated */
  updatedAt?: string
}

export interface Report {
  /** Timestamp when the report was created */
  createdAt?: string
  /** ID of the user who created the report */
  createdBy: string
  /** Description of the report (optional) */
  description?: string
  /** Unique identifier for the report */
  id?: string
  /** List of IDs of related project galleries */
  projectGalleryId: string[]
  /** ID of the project */
  projectId: string
  /** Date of the report */
  reportDate: string
  /** ID of the report subject */
  reportSubjectId: string
  /** Time of the report */
  reportTime: string
  /** Title of the report */
  title: string
  /** Timestamp when the report was last updated */
  updatedAt?: string
}

export interface Province {
  /** Code of the province */
  code: number
  /** ID of the country */
  countryId: string
  /** Timestamp when the province was created */
  createdAt?: string
  /** Unique identifier for the province */
  id?: string
  /** Name of the province */
  name: string
  /** Timestamp when the province was last updated */
  updatedAt?: string
}

/**
 * The current status of the project.
 */
export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProjectStatus = {
  Initiation: 'Initiation',
  'Pre-Construction': 'Pre-Construction',
  'In-Progress': 'In-Progress',
  Compeleted: 'Compeleted',
} as const

/**
 * The unit of measurement for the project's area dimensions.
 */
export type ProjectMeasureUnit =
  (typeof ProjectMeasureUnit)[keyof typeof ProjectMeasureUnit]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ProjectMeasureUnit = {
  m: 'm',
  cm: 'cm',
  in: 'in',
  ft: 'ft',
} as const

export interface Project {
  /** The ID of the admin associated with the project. */
  adminId: string
  /** The height of the project area. */
  areaHeight: number
  /** The length of the project area. */
  areaLength: number
  /** The width of the project area. */
  areaWidth: number
  /** Timestamp when the project was created. */
  createdAt?: string
  /** A brief description of the project. */
  description?: string
  /** List of employee IDs associated with the project. */
  employees?: string[]
  /** List of equipment IDs associated with the project. */
  equipment?: string[]
  /** Unique identifier for the project. */
  id?: string
  /** The latitude coordinate of the project's location. */
  latitude: number
  /** The longitude coordinate of the project's location. */
  longitude: number
  /** List of material IDs associated with the project. */
  materials?: string[]
  /** The unit of measurement for the project's area dimensions. */
  measureUnit: ProjectMeasureUnit
  /** The project code, generated automatically. */
  projectCode: string
  /** The current status of the project. */
  status?: ProjectStatus
  /** The title of the project. */
  title: string
  /** Timestamp when the project was last updated. */
  updatedAt?: string
  /** The ID of the zone where the project is located. */
  zoneId: string
}

export interface ProjectGallerySubject {
  /** Timestamp when the gallery subject was created */
  createdAt?: string
  /** Description of the gallery subject */
  description?: string
  /** Unique identifier for the gallery subject */
  id?: string
  /** Title of the gallery subject */
  title: string
  /** Timestamp when the gallery subject was last updated */
  updatedAt?: string
}

export interface ProjectGallery {
  /** Timestamp when the project gallery was created */
  createdAt?: string
  /** Description of the media */
  description?: string
  /** Unique identifier for the project gallery */
  id?: string
  /** Location where the media was taken */
  location?: string
  /** Date and time of the media */
  mediaDateTime?: string
  /** Name of the media */
  mediaName: string
  /** ID of the media subject */
  mediaSubjectId?: string
  /** URL of the media */
  mediaUrl: string
  /** ID of the project */
  projectId: string
  /** URL of the thumbnail media */
  thumbnailMediaUrl?: string
  /** Timestamp when the project gallery was last updated */
  updatedAt?: string
  /** ID of the user */
  userId: string
}

export type ProjectCostMaterialsItem = {
  /** Cost per unit of the material */
  costPerUnit?: number
  /** ID of the material */
  materialId?: string
  /** Value of the material */
  value?: number
}

export type ProjectCostEquipmentItem = {
  /** Cost per hour of using the equipment */
  costPerHour?: number
  /** Number of hours the equipment is used */
  countHour?: number
  /** ID of the equipment */
  equipmentId?: string
}

export type ProjectCostEmployeesItem = {
  /** Cost per hour of the employee */
  costPerHour?: number
  /** Number of hours the employee worked */
  countHour?: number
  /** ID of the employee */
  employeeId?: string
}

export interface ProjectCost {
  /** Date when the cost was recorded */
  costDate: string
  /** Timestamp when the project cost entry was created */
  createdAt?: string
  /** List of employees and their costs */
  employees: ProjectCostEmployeesItem[]
  /** List of equipment and their costs */
  equipment: ProjectCostEquipmentItem[]
  /** Unique identifier for the project cost entry */
  id?: string
  /** List of materials and their costs */
  materials: ProjectCostMaterialsItem[]
  /** ID of the project */
  projectId: string
  /** Total cost of the project */
  totalCost: number
  /** Timestamp when the project cost entry was last updated */
  updatedAt?: string
}

export type ProjectAssignmentEquipmentItem = {
  /** ID of the equipment */
  equipmentId?: Equipment
  /** Estimated count of hours for the equipment */
  estimatedCountHour?: number
}

export type ProjectAssignmentEmployeesItem = {
  /** ID of the employee */
  employeeId?: Employee
  /** Estimated count of hours for the employee */
  estimatedCountHour?: number
}

/**
 * Schema for project assignments
 */
export interface ProjectAssignment {
  /** Timestamp when the ProjectAssignment was created */
  createdAt?: string
  /** Description of the project assignment */
  description?: string
  employees?: ProjectAssignmentEmployeesItem[]
  equipment?: ProjectAssignmentEquipmentItem[]
  /** Unique identifier for the ProjectAssignment */
  id?: string
  materials?: ProjectAssignmentMaterialsItem[]
  /** ID of the project */
  projectId: Project
  /** Total estimated count of days for the project assignment */
  totalEstimatedCountDays?: number
  /** Timestamp when the ProjectAssignment was last updated */
  updatedAt?: string
}

/**
 * Schema for user permissions on a resource
 */
export interface Permission {
  /** Permission to delete the resource */
  canDelete?: boolean
  /** Permission to edit the resource */
  canEdit?: boolean
  /** Permission to read the resource */
  canRead?: boolean
  /** Permission to write to the resource */
  canWrite?: boolean
  /** Timestamp when the Permission was created */
  createdAt?: string
  /** Unique identifier for the Permission */
  id?: string
  /** ID of the resource */
  resourceId: Resource
  /** Timestamp when the Permission was last updated */
  updatedAt?: string
  /** ID of the user */
  userId: User
}

export type OperatorAllOf = {
  /** Timestamp when the Operator was created */
  createdAt?: string
  /** Date when the operator was hired */
  hireDate?: string
  /** Unique identifier for the Operator */
  id?: string
  /** Unique code assigned to the operator */
  operatorCode?: number
  /** Timestamp when the Operator was last updated */
  updatedAt?: string
}

export type Operator = User & OperatorAllOf

/**
 * Unit of measurement for the material
 */
export type MaterialUnit = (typeof MaterialUnit)[keyof typeof MaterialUnit]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const MaterialUnit = {
  gr: 'gr',
  Kg: 'Kg',
  Tone: 'Tone',
} as const

/**
 * Schema for material details
 */
export interface Material {
  /** Timestamp when the Material was created */
  createdAt?: string
  /** Description of the material */
  description: string
  /** Unique identifier for the Material */
  id?: string
  /** Unique code for the Material */
  materialtCode?: string
  /** Name of the material */
  name: string
  /**
   * Price per unit of the material
   * @minimum 0
   */
  pricePerUnit?: number
  /** Unit of measurement for the material */
  unit: MaterialUnit
  /** Timestamp when the Material was last updated */
  updatedAt?: string
  /**
   * Value of the material
   * @minimum 0
   */
  value: number
}

export type ProjectAssignmentMaterialsItem = {
  /** Estimated value of the material */
  estimatedValue?: number
  /** ID of the material */
  materialId?: Material
}

/**
 * Schema for job details
 */
export interface Job {
  /** Timestamp when the Job was created */
  createdAt?: string
  /** Description of the job */
  description: string
  /** Unique identifier for the Job */
  id?: string
  /** Title of the job */
  title: string
  /** Timestamp when the Job was last updated */
  updatedAt?: string
}

export type InjuryEmployeeReportAllOf = {[key: string]: unknown}

export type InjuryEmployeeReport = Report &
  InjuryEmployeeReportAllOf & {
    /** Timestamp when the Injury Employee Report was created */
    createdAt?: string
    /** ID of the user who created the report */
    createdBy: string
    /** Description of the report (optional) */
    description?: string
    /** ID of the employee related to the report */
    employeeId: string
    /** Unique identifier for the Injury Employee Report */
    id?: string
    /** IDs of the related project galleries */
    projectGalleryId: string[]
    /** ID of the project */
    projectId: string
    /** Date of the report */
    reportDate: string
    /** ID of the report subject */
    reportSubjectId: string
    /** Time of the report */
    reportTime: string
    /** Title of the report */
    title: string
    /** Timestamp when the Injury Employee Report was last updated */
    updatedAt?: string
  }

/**
 * Schema for equipment details
 */
export interface Equipment {
  /** Number of available units of the equipment */
  count: number
  /** Timestamp when the equipment was created */
  createdAt: string
  /** Description of the equipment */
  description?: string
  /** Unique code for the equipment */
  equipmentCode?: string
  /** Model of the equipment */
  equipmentModel: string
  /** Unique identifier for the equipment */
  id?: string
  /** Manufacturer of the equipment */
  Manufacturer: string
  /** Name of the equipment */
  name: string
  /** Price per hour for using the equipment */
  pricePerHour?: number
  /** Timestamp when the equipment was last updated */
  updatedAt: string
  /** Vehicle Identification Number of the equipment */
  VIN: string
}

export type Employee = User & EmployeeAllOf

/**
 * Marital status of the employee
 */
export type EmployeeAllOfMaritalStatus =
  (typeof EmployeeAllOfMaritalStatus)[keyof typeof EmployeeAllOfMaritalStatus]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmployeeAllOfMaritalStatus = {
  Single: 'Single',
  Married: 'Married',
  Divorced: 'Divorced',
  Widowed: 'Widowed',
} as const

/**
 * Type of employment contract
 */
export type EmployeeAllOfContractType =
  (typeof EmployeeAllOfContractType)[keyof typeof EmployeeAllOfContractType]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const EmployeeAllOfContractType = {
  Permanent: 'Permanent',
  Temporary: 'Temporary',
  Contract: 'Contract',
  Intern: 'Intern',
} as const

export type EmployeeAllOf = {
  /** Bank account information for salary payment */
  bankAccountInfo?: string
  /** Type of employment contract */
  contractType?: EmployeeAllOfContractType
  /** Timestamp when the Employee was created */
  createdAt?: string
  /** Employee's date of birth */
  dateOfBirth?: string
  /** General description about the employee */
  description?: string
  /** Unique code assigned to the employee */
  employeeCode?: number
  /** Date when the employee was hired */
  hireDate?: string
  /** Unique identifier for the Employee */
  id?: string
  /** Employee's insurance number */
  insuranceNumber?: number
  /** Reference to the Job ID */
  jobId?: string
  /** Marital status of the employee */
  maritalStatus?: EmployeeAllOfMaritalStatus
  /** National ID of the user (optional) */
  nationalId?: string
  /** Description of the employee's skills */
  skillDescription?: string
  /** Timestamp when the Employee was last updated */
  updatedAt?: string
  /** Number of years of work experience */
  yearsOfExperience?: number
}

export type DamageEquipmentReportAllOf = {[key: string]: unknown}

export type DamageEquipmentReport = Report &
  DamageEquipmentReportAllOf & {
    /** Timestamp when the Damage Equipment Report was created */
    createdAt?: string
    /** ID of the user who created the report */
    createdBy: string
    /** Description of the report (optional) */
    description?: string
    /** ID of the equipment related to the report */
    equipmentId: string
    /** Unique identifier for the Damage Equipment Report */
    id?: string
    /** IDs of the related project galleries */
    projectGalleryId: string[]
    /** ID of the project */
    projectId: string
    /** Date of the report */
    reportDate: string
    /** ID of the report subject */
    reportSubjectId: string
    /** Time of the report */
    reportTime: string
    /** Title of the report */
    title: string
    /** Timestamp when the Damage Equipment Report was last updated */
    updatedAt?: string
  }

export type DailyReportAllOf = {[key: string]: unknown}

export type DailyReport = Report &
  DailyReportAllOf & {
    /** Timestamp when the Daily Report was created */
    createdAt?: string
    /** ID of the user who created the report */
    createdBy: string
    /** Description of the report (optional) */
    description?: string
    /** Unique identifier for the Daily Report */
    id?: string
    /** List of IDs of related project galleries */
    projectGalleryId: string[]
    /** ID of the project */
    projectId: string
    /** Date of the report */
    reportDate: string
    /** ID of the report subject */
    reportSubjectId: string
    /** Time of the report */
    reportTime: string
    /** Title of the report */
    title: string
    /** Timestamp when the Daily Report was last updated */
    updatedAt?: string
  }

export interface Country {
  /** Total area of the country */
  area: number
  /** Capital city of the country */
  capital: string
  /** Unique code of the country */
  code: string
  /** Timestamp when the Country was created */
  createdAt?: string
  /** Currency used in the country */
  currency: string
  /** URL of the country's flag */
  flagUrl: string
  /** Unique Geoname ID of the country */
  geonameId: number
  /** Unique identifier for the Country */
  id?: string
  /** Languages spoken in the country */
  languages: string[]
  /** Name of the country */
  name: string
  /** Population of the country */
  population: number
  /** Timestamp when the Country was last updated */
  updatedAt?: string
}

export interface AssetEquipment {
  /** Cost per hour of using the equipment */
  costPerHour?: number
  /** Number of hours the equipment is used */
  countHour: number
  /** ID of the equipment */
  equipmentId: string
}

export interface AssetMaterial {
  /** Cost per unit of the material */
  costPerUnit?: number
  /** Timestamp when the Asset Material was created */
  createdAt?: string
  /** Unique identifier for the Asset Material */
  id?: string
  /** ID of the material */
  materialId: string
  /** Timestamp when the Asset Material was last updated */
  updatedAt?: string
  /** Value of the material */
  value: number
}

export interface Asset {
  equipment?: AssetEquipment[]
  materials?: AssetMaterial[]
}

/**
 * Gender of the admin
 */
export type AdminGender = (typeof AdminGender)[keyof typeof AdminGender]

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AdminGender = {
  male: 'male',
  female: 'female',
  other: 'other',
} as const

export type AdminAllOf = {[key: string]: unknown}

export type Admin = User &
  AdminAllOf & {
    /** Address of the admin */
    address: string
    /** Timestamp when the admin was created */
    createdAt?: string
    /** Email address of the admin */
    email: string
    /** First name of the admin */
    firstName: string
    /** Gender of the admin */
    gender: AdminGender
    /** Unique identifier for the admin */
    id?: string
    /** Timestamp of the admin's last activity (optional) */
    lastActivity?: number
    /** Last name of the admin */
    lastName: string
    /** Mobile number of the admin */
    mobile: string
    /** National ID of the admin (optional) */
    nationalId?: string
    /** Password for the admin */
    password: string
    /** List of permission IDs associated with the admin */
    permissions?: string[]
    /** URL to the profile photo of the admin (optional) */
    profilePhoto?: string
    /** Role ID of the admin */
    roleId: string
    /** Telephone number of the admin (optional) */
    telephone?: string
    /** Timestamp when the admin was last updated */
    updatedAt?: string
  }

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

/**
 * @summary Get all admins
 */
export const getAllAdmins = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Admin[]>(
    {url: `/admins`, method: 'GET', signal},
    options,
  )
}

export const getGetAllAdminsQueryKey = () => {
  return [`/admins`] as const
}

export const getGetAllAdminsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllAdmins>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllAdmins>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllAdminsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllAdmins>>> = ({
    signal,
  }) => getAllAdmins(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllAdmins>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllAdminsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllAdmins>>
>
export type GetAllAdminsQueryError = ErrorType<void>

/**
 * @summary Get all admins
 */
export const useGetAllAdmins = <
  TData = Awaited<ReturnType<typeof getAllAdmins>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllAdmins>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllAdminsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllAdminsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllAdmins>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllAdmins>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllAdminsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllAdmins>>> = ({
    signal,
  }) => getAllAdmins(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllAdmins>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllAdminsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllAdmins>>
>
export type GetAllAdminsSuspenseQueryError = ErrorType<void>

/**
 * @summary Get all admins
 */
export const useGetAllAdminsSuspense = <
  TData = Awaited<ReturnType<typeof getAllAdmins>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllAdmins>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllAdminsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create a new admin
 */
export const createAdmin = (
  admin: BodyType<Admin>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Admin>(
    {
      url: `/admins`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: admin,
    },
    options,
  )
}

export const getCreateAdminMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAdmin>>,
    TError,
    {data: BodyType<Admin>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createAdmin>>,
  TError,
  {data: BodyType<Admin>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createAdmin>>,
    {data: BodyType<Admin>}
  > = (props) => {
    const {data} = props ?? {}

    return createAdmin(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateAdminMutationResult = NonNullable<
  Awaited<ReturnType<typeof createAdmin>>
>
export type CreateAdminMutationBody = BodyType<Admin>
export type CreateAdminMutationError = ErrorType<void>

/**
 * @summary Create a new admin
 */
export const useCreateAdmin = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createAdmin>>,
    TError,
    {data: BodyType<Admin>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createAdmin>>,
  TError,
  {data: BodyType<Admin>},
  TContext
> => {
  const mutationOptions = getCreateAdminMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get admin by ID
 */
export const getAdminById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Admin>(
    {url: `/admins/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetAdminByIdQueryKey = (id: string) => {
  return [`/admins/${id}`] as const
}

export const getGetAdminByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getAdminById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdminById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAdminByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminById>>> = ({
    signal,
  }) => getAdminById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAdminById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAdminByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAdminById>>
>
export type GetAdminByIdQueryError = ErrorType<void>

/**
 * @summary Get admin by ID
 */
export const useGetAdminById = <
  TData = Awaited<ReturnType<typeof getAdminById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAdminById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAdminByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAdminByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAdminById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAdminById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAdminByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAdminById>>> = ({
    signal,
  }) => getAdminById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAdminById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAdminByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAdminById>>
>
export type GetAdminByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get admin by ID
 */
export const useGetAdminByIdSuspense = <
  TData = Awaited<ReturnType<typeof getAdminById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAdminById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAdminByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Get all assets
 */
export const getAssets = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Asset[]>(
    {url: `/assets`, method: 'GET', signal},
    options,
  )
}

export const getGetAssetsQueryKey = () => {
  return [`/assets`] as const
}

export const getGetAssetsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAssets>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAssets>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAssetsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssets>>> = ({
    signal,
  }) => getAssets(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAssets>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAssetsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAssets>>
>
export type GetAssetsQueryError = ErrorType<void>

/**
 * @summary Get all assets
 */
export const useGetAssets = <
  TData = Awaited<ReturnType<typeof getAssets>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAssets>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAssetsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAssetsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAssets>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAssets>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAssetsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssets>>> = ({
    signal,
  }) => getAssets(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAssets>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAssetsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAssets>>
>
export type GetAssetsSuspenseQueryError = ErrorType<void>

/**
 * @summary Get all assets
 */
export const useGetAssetsSuspense = <
  TData = Awaited<ReturnType<typeof getAssets>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAssets>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAssetsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create a new asset
 */
export const postAssets = (
  asset: BodyType<Asset>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Asset>(
    {
      url: `/assets`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: asset,
    },
    options,
  )
}

export const getPostAssetsMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAssets>>,
    TError,
    {data: BodyType<Asset>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof postAssets>>,
  TError,
  {data: BodyType<Asset>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAssets>>,
    {data: BodyType<Asset>}
  > = (props) => {
    const {data} = props ?? {}

    return postAssets(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type PostAssetsMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAssets>>
>
export type PostAssetsMutationBody = BodyType<Asset>
export type PostAssetsMutationError = ErrorType<void>

/**
 * @summary Create a new asset
 */
export const usePostAssets = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAssets>>,
    TError,
    {data: BodyType<Asset>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof postAssets>>,
  TError,
  {data: BodyType<Asset>},
  TContext
> => {
  const mutationOptions = getPostAssetsMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get asset by ID
 */
export const getAssetsId = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Asset>(
    {url: `/assets/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetAssetsIdQueryKey = (id: string) => {
  return [`/assets/${id}`] as const
}

export const getGetAssetsIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getAssetsId>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAssetsId>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAssetsIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssetsId>>> = ({
    signal,
  }) => getAssetsId(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAssetsId>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAssetsIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAssetsId>>
>
export type GetAssetsIdQueryError = ErrorType<void>

/**
 * @summary Get asset by ID
 */
export const useGetAssetsId = <
  TData = Awaited<ReturnType<typeof getAssetsId>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAssetsId>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAssetsIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAssetsIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAssetsId>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAssetsId>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAssetsIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAssetsId>>> = ({
    signal,
  }) => getAssetsId(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAssetsId>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAssetsIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAssetsId>>
>
export type GetAssetsIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get asset by ID
 */
export const useGetAssetsIdSuspense = <
  TData = Awaited<ReturnType<typeof getAssetsId>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getAssetsId>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAssetsIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update an asset by ID
 */
export const putAssetsId = (
  id: string,
  asset: BodyType<Asset>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Asset>(
    {
      url: `/assets/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: asset,
    },
    options,
  )
}

export const getPutAssetsIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putAssetsId>>,
    TError,
    {id: string; data: BodyType<Asset>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof putAssetsId>>,
  TError,
  {id: string; data: BodyType<Asset>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putAssetsId>>,
    {id: string; data: BodyType<Asset>}
  > = (props) => {
    const {id, data} = props ?? {}

    return putAssetsId(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type PutAssetsIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof putAssetsId>>
>
export type PutAssetsIdMutationBody = BodyType<Asset>
export type PutAssetsIdMutationError = ErrorType<void>

/**
 * @summary Update an asset by ID
 */
export const usePutAssetsId = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putAssetsId>>,
    TError,
    {id: string; data: BodyType<Asset>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof putAssetsId>>,
  TError,
  {id: string; data: BodyType<Asset>},
  TContext
> => {
  const mutationOptions = getPutAssetsIdMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Delete an asset by ID
 */
export const deleteAssetsId = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>({url: `/assets/${id}`, method: 'DELETE'}, options)
}

export const getDeleteAssetsIdMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAssetsId>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteAssetsId>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteAssetsId>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteAssetsId(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteAssetsIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteAssetsId>>
>

export type DeleteAssetsIdMutationError = ErrorType<void>

/**
 * @summary Delete an asset by ID
 */
export const useDeleteAssetsId = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteAssetsId>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteAssetsId>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteAssetsIdMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Logs in a user
 */
export const loginUser = (
  loginUserBody: BodyType<LoginUserBody>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<LoginUser200>(
    {
      url: `/auth/login`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: loginUserBody,
    },
    options,
  )
}

export const getLoginUserMutationOptions = <
  TError = ErrorType<LoginUser400One>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginUser>>,
    TError,
    {data: BodyType<LoginUserBody>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof loginUser>>,
  TError,
  {data: BodyType<LoginUserBody>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof loginUser>>,
    {data: BodyType<LoginUserBody>}
  > = (props) => {
    const {data} = props ?? {}

    return loginUser(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type LoginUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof loginUser>>
>
export type LoginUserMutationBody = BodyType<LoginUserBody>
export type LoginUserMutationError = ErrorType<LoginUser400One>

/**
 * @summary Logs in a user
 */
export const useLoginUser = <
  TError = ErrorType<LoginUser400One>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof loginUser>>,
    TError,
    {data: BodyType<LoginUserBody>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof loginUser>>,
  TError,
  {data: BodyType<LoginUserBody>},
  TContext
> => {
  const mutationOptions = getLoginUserMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Refreshes the access token
 */
export const refreshToken = (
  refreshTokenBody: BodyType<RefreshTokenBody>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<RefreshToken200>(
    {
      url: `/auth/refreshToken`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: refreshTokenBody,
    },
    options,
  )
}

export const getRefreshTokenMutationOptions = <
  TError = ErrorType<RefreshToken400One | RefreshToken404One>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshToken>>,
    TError,
    {data: BodyType<RefreshTokenBody>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof refreshToken>>,
  TError,
  {data: BodyType<RefreshTokenBody>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof refreshToken>>,
    {data: BodyType<RefreshTokenBody>}
  > = (props) => {
    const {data} = props ?? {}

    return refreshToken(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type RefreshTokenMutationResult = NonNullable<
  Awaited<ReturnType<typeof refreshToken>>
>
export type RefreshTokenMutationBody = BodyType<RefreshTokenBody>
export type RefreshTokenMutationError = ErrorType<
  RefreshToken400One | RefreshToken404One
>

/**
 * @summary Refreshes the access token
 */
export const useRefreshToken = <
  TError = ErrorType<RefreshToken400One | RefreshToken404One>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof refreshToken>>,
    TError,
    {data: BodyType<RefreshTokenBody>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof refreshToken>>,
  TError,
  {data: BodyType<RefreshTokenBody>},
  TContext
> => {
  const mutationOptions = getRefreshTokenMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Log out the user by blacklisting the provided access token.
 * @summary Log out the user
 */
export const logout = (options?: SecondParameter<typeof axiosInstance>) => {
  return axiosInstance<Logout200>(
    {url: `/auth/logout`, method: 'POST'},
    options,
  )
}

export const getLogoutMutationOptions = <
  TError = ErrorType<Logout401 | Logout500>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof logout>>,
    void
  > = () => {
    return logout(requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type LogoutMutationResult = NonNullable<
  Awaited<ReturnType<typeof logout>>
>

export type LogoutMutationError = ErrorType<Logout401 | Logout500>

/**
 * @summary Log out the user
 */
export const useLogout = <
  TError = ErrorType<Logout401 | Logout500>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof logout>>,
    TError,
    void,
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof logout>>,
  TError,
  void,
  TContext
> => {
  const mutationOptions = getLogoutMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Signs up a new user
 */
export const signupUser = (
  signupUserBody: BodyType<SignupUserBody>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<UserInfo>(
    {
      url: `/auth/signup`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: signupUserBody,
    },
    options,
  )
}

export const getSignupUserMutationOptions = <
  TError = ErrorType<SignupUser400One>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signupUser>>,
    TError,
    {data: BodyType<SignupUserBody>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof signupUser>>,
  TError,
  {data: BodyType<SignupUserBody>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof signupUser>>,
    {data: BodyType<SignupUserBody>}
  > = (props) => {
    const {data} = props ?? {}

    return signupUser(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type SignupUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof signupUser>>
>
export type SignupUserMutationBody = BodyType<SignupUserBody>
export type SignupUserMutationError = ErrorType<SignupUser400One>

/**
 * @summary Signs up a new user
 */
export const useSignupUser = <
  TError = ErrorType<SignupUser400One>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof signupUser>>,
    TError,
    {data: BodyType<SignupUserBody>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof signupUser>>,
  TError,
  {data: BodyType<SignupUserBody>},
  TContext
> => {
  const mutationOptions = getSignupUserMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a country by its ID
 * @summary Get country by ID
 */
export const getCountryById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Country>(
    {url: `/countries/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetCountryByIdQueryKey = (id: string) => {
  return [`/countries/${id}`] as const
}

export const getGetCountryByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getCountryById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCountryById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCountryByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCountryById>>> = ({
    signal,
  }) => getCountryById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getCountryById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetCountryByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCountryById>>
>
export type GetCountryByIdQueryError = ErrorType<void>

/**
 * @summary Get country by ID
 */
export const useGetCountryById = <
  TData = Awaited<ReturnType<typeof getCountryById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getCountryById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetCountryByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetCountryByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getCountryById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCountryById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetCountryByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getCountryById>>> = ({
    signal,
  }) => getCountryById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getCountryById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetCountryByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getCountryById>>
>
export type GetCountryByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get country by ID
 */
export const useGetCountryByIdSuspense = <
  TData = Awaited<ReturnType<typeof getCountryById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getCountryById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetCountryByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a country by its ID
 * @summary Update a country by ID
 */
export const updateCountry = (
  id: string,
  country: BodyType<Country>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Country>(
    {
      url: `/countries/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: country,
    },
    options,
  )
}

export const getUpdateCountryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCountry>>,
    TError,
    {id: string; data: BodyType<Country>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateCountry>>,
  TError,
  {id: string; data: BodyType<Country>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateCountry>>,
    {id: string; data: BodyType<Country>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateCountry(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateCountryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateCountry>>
>
export type UpdateCountryMutationBody = BodyType<Country>
export type UpdateCountryMutationError = ErrorType<void>

/**
 * @summary Update a country by ID
 */
export const useUpdateCountry = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateCountry>>,
    TError,
    {id: string; data: BodyType<Country>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateCountry>>,
  TError,
  {id: string; data: BodyType<Country>},
  TContext
> => {
  const mutationOptions = getUpdateCountryMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a country by its ID
 * @summary Delete a country by ID
 */
export const deleteCountry = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/countries/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteCountryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCountry>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteCountry>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteCountry>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteCountry(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteCountryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteCountry>>
>

export type DeleteCountryMutationError = ErrorType<void>

/**
 * @summary Delete a country by ID
 */
export const useDeleteCountry = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteCountry>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteCountry>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteCountryMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all countries
 * @summary Get all countries
 */
export const getAllCountries = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Country[]>(
    {url: `/countries`, method: 'GET', signal},
    options,
  )
}

export const getGetAllCountriesQueryKey = () => {
  return [`/countries`] as const
}

export const getGetAllCountriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllCountries>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllCountries>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllCountriesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCountries>>> = ({
    signal,
  }) => getAllCountries(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllCountries>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllCountriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllCountries>>
>
export type GetAllCountriesQueryError = ErrorType<void>

/**
 * @summary Get all countries
 */
export const useGetAllCountries = <
  TData = Awaited<ReturnType<typeof getAllCountries>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllCountries>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllCountriesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllCountriesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllCountries>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllCountries>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllCountriesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllCountries>>> = ({
    signal,
  }) => getAllCountries(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllCountries>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllCountriesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllCountries>>
>
export type GetAllCountriesSuspenseQueryError = ErrorType<void>

/**
 * @summary Get all countries
 */
export const useGetAllCountriesSuspense = <
  TData = Awaited<ReturnType<typeof getAllCountries>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllCountries>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllCountriesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new country with the provided data
 * @summary Create a new country
 */
export const createCountry = (
  country: BodyType<Country>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Country>(
    {
      url: `/countries`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: country,
    },
    options,
  )
}

export const getCreateCountryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCountry>>,
    TError,
    {data: BodyType<Country>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createCountry>>,
  TError,
  {data: BodyType<Country>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createCountry>>,
    {data: BodyType<Country>}
  > = (props) => {
    const {data} = props ?? {}

    return createCountry(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateCountryMutationResult = NonNullable<
  Awaited<ReturnType<typeof createCountry>>
>
export type CreateCountryMutationBody = BodyType<Country>
export type CreateCountryMutationError = ErrorType<void>

/**
 * @summary Create a new country
 */
export const useCreateCountry = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createCountry>>,
    TError,
    {data: BodyType<Country>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createCountry>>,
  TError,
  {data: BodyType<Country>},
  TContext
> => {
  const mutationOptions = getCreateCountryMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all daily reports
 * @summary Get all daily reports
 */
export const getAllDailyReports = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<DailyReport[]>(
    {url: `/dailyReports`, method: 'GET', signal},
    options,
  )
}

export const getGetAllDailyReportsQueryKey = () => {
  return [`/dailyReports`] as const
}

export const getGetAllDailyReportsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllDailyReports>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllDailyReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllDailyReportsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllDailyReports>>
  > = ({signal}) => getAllDailyReports(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllDailyReports>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllDailyReportsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllDailyReports>>
>
export type GetAllDailyReportsQueryError = ErrorType<void>

/**
 * @summary Get all daily reports
 */
export const useGetAllDailyReports = <
  TData = Awaited<ReturnType<typeof getAllDailyReports>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllDailyReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllDailyReportsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllDailyReportsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllDailyReports>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllDailyReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllDailyReportsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllDailyReports>>
  > = ({signal}) => getAllDailyReports(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllDailyReports>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllDailyReportsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllDailyReports>>
>
export type GetAllDailyReportsSuspenseQueryError = ErrorType<void>

/**
 * @summary Get all daily reports
 */
export const useGetAllDailyReportsSuspense = <
  TData = Awaited<ReturnType<typeof getAllDailyReports>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllDailyReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllDailyReportsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new daily report with the provided data
 * @summary Create a new daily report
 */
export const createDailyReport = (
  dailyReport: BodyType<DailyReport>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<DailyReport>(
    {
      url: `/dailyReports`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: dailyReport,
    },
    options,
  )
}

export const getCreateDailyReportMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDailyReport>>,
    TError,
    {data: BodyType<DailyReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDailyReport>>,
  TError,
  {data: BodyType<DailyReport>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDailyReport>>,
    {data: BodyType<DailyReport>}
  > = (props) => {
    const {data} = props ?? {}

    return createDailyReport(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateDailyReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDailyReport>>
>
export type CreateDailyReportMutationBody = BodyType<DailyReport>
export type CreateDailyReportMutationError = ErrorType<void>

/**
 * @summary Create a new daily report
 */
export const useCreateDailyReport = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDailyReport>>,
    TError,
    {data: BodyType<DailyReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createDailyReport>>,
  TError,
  {data: BodyType<DailyReport>},
  TContext
> => {
  const mutationOptions = getCreateDailyReportMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a daily report by its ID
 * @summary Get daily report by ID
 */
export const getDailyReportById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<DailyReport>(
    {url: `/dailyReports/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetDailyReportByIdQueryKey = (id: string) => {
  return [`/dailyReports/${id}`] as const
}

export const getGetDailyReportByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getDailyReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDailyReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetDailyReportByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDailyReportById>>
  > = ({signal}) => getDailyReportById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getDailyReportById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetDailyReportByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDailyReportById>>
>
export type GetDailyReportByIdQueryError = ErrorType<void>

/**
 * @summary Get daily report by ID
 */
export const useGetDailyReportById = <
  TData = Awaited<ReturnType<typeof getDailyReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDailyReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetDailyReportByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetDailyReportByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getDailyReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDailyReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetDailyReportByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDailyReportById>>
  > = ({signal}) => getDailyReportById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getDailyReportById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetDailyReportByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDailyReportById>>
>
export type GetDailyReportByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get daily report by ID
 */
export const useGetDailyReportByIdSuspense = <
  TData = Awaited<ReturnType<typeof getDailyReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDailyReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetDailyReportByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a daily report by its ID
 * @summary Update a daily report by ID
 */
export const updateDailyReport = (
  id: string,
  dailyReport: BodyType<DailyReport>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<DailyReport>(
    {
      url: `/dailyReports/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: dailyReport,
    },
    options,
  )
}

export const getUpdateDailyReportMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDailyReport>>,
    TError,
    {id: string; data: BodyType<DailyReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDailyReport>>,
  TError,
  {id: string; data: BodyType<DailyReport>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDailyReport>>,
    {id: string; data: BodyType<DailyReport>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateDailyReport(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateDailyReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDailyReport>>
>
export type UpdateDailyReportMutationBody = BodyType<DailyReport>
export type UpdateDailyReportMutationError = ErrorType<void>

/**
 * @summary Update a daily report by ID
 */
export const useUpdateDailyReport = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDailyReport>>,
    TError,
    {id: string; data: BodyType<DailyReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateDailyReport>>,
  TError,
  {id: string; data: BodyType<DailyReport>},
  TContext
> => {
  const mutationOptions = getUpdateDailyReportMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a daily report by its ID
 * @summary Delete a daily report by ID
 */
export const deleteDailyReport = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/dailyReports/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteDailyReportMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDailyReport>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteDailyReport>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDailyReport>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteDailyReport(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteDailyReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDailyReport>>
>

export type DeleteDailyReportMutationError = ErrorType<void>

/**
 * @summary Delete a daily report by ID
 */
export const useDeleteDailyReport = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDailyReport>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteDailyReport>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteDailyReportMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all damage equipment reports
 * @summary Get all damage equipment reports
 */
export const getAllDamageEquipmentReports = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<DamageEquipmentReport[]>(
    {url: `/damageEquipmentReports`, method: 'GET', signal},
    options,
  )
}

export const getGetAllDamageEquipmentReportsQueryKey = () => {
  return [`/damageEquipmentReports`] as const
}

export const getGetAllDamageEquipmentReportsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllDamageEquipmentReports>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllDamageEquipmentReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllDamageEquipmentReportsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllDamageEquipmentReports>>
  > = ({signal}) => getAllDamageEquipmentReports(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllDamageEquipmentReports>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllDamageEquipmentReportsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllDamageEquipmentReports>>
>
export type GetAllDamageEquipmentReportsQueryError = ErrorType<void>

/**
 * @summary Get all damage equipment reports
 */
export const useGetAllDamageEquipmentReports = <
  TData = Awaited<ReturnType<typeof getAllDamageEquipmentReports>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllDamageEquipmentReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllDamageEquipmentReportsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllDamageEquipmentReportsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllDamageEquipmentReports>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllDamageEquipmentReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllDamageEquipmentReportsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllDamageEquipmentReports>>
  > = ({signal}) => getAllDamageEquipmentReports(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllDamageEquipmentReports>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllDamageEquipmentReportsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllDamageEquipmentReports>>
>
export type GetAllDamageEquipmentReportsSuspenseQueryError = ErrorType<void>

/**
 * @summary Get all damage equipment reports
 */
export const useGetAllDamageEquipmentReportsSuspense = <
  TData = Awaited<ReturnType<typeof getAllDamageEquipmentReports>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllDamageEquipmentReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions =
    getGetAllDamageEquipmentReportsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new damage equipment report with the provided data
 * @summary Create a new damage equipment report
 */
export const createDamageEquipmentReport = (
  damageEquipmentReport: BodyType<DamageEquipmentReport>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<DamageEquipmentReport>(
    {
      url: `/damageEquipmentReports`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: damageEquipmentReport,
    },
    options,
  )
}

export const getCreateDamageEquipmentReportMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDamageEquipmentReport>>,
    TError,
    {data: BodyType<DamageEquipmentReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createDamageEquipmentReport>>,
  TError,
  {data: BodyType<DamageEquipmentReport>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createDamageEquipmentReport>>,
    {data: BodyType<DamageEquipmentReport>}
  > = (props) => {
    const {data} = props ?? {}

    return createDamageEquipmentReport(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateDamageEquipmentReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof createDamageEquipmentReport>>
>
export type CreateDamageEquipmentReportMutationBody =
  BodyType<DamageEquipmentReport>
export type CreateDamageEquipmentReportMutationError = ErrorType<void>

/**
 * @summary Create a new damage equipment report
 */
export const useCreateDamageEquipmentReport = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createDamageEquipmentReport>>,
    TError,
    {data: BodyType<DamageEquipmentReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createDamageEquipmentReport>>,
  TError,
  {data: BodyType<DamageEquipmentReport>},
  TContext
> => {
  const mutationOptions = getCreateDamageEquipmentReportMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a damage equipment report by its ID
 * @summary Get damage equipment report by ID
 */
export const getDamageEquipmentReportById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<DamageEquipmentReport>(
    {url: `/damageEquipmentReports/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetDamageEquipmentReportByIdQueryKey = (id: string) => {
  return [`/damageEquipmentReports/${id}`] as const
}

export const getGetDamageEquipmentReportByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getDamageEquipmentReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDamageEquipmentReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetDamageEquipmentReportByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDamageEquipmentReportById>>
  > = ({signal}) => getDamageEquipmentReportById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getDamageEquipmentReportById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetDamageEquipmentReportByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDamageEquipmentReportById>>
>
export type GetDamageEquipmentReportByIdQueryError = ErrorType<void>

/**
 * @summary Get damage equipment report by ID
 */
export const useGetDamageEquipmentReportById = <
  TData = Awaited<ReturnType<typeof getDamageEquipmentReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getDamageEquipmentReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetDamageEquipmentReportByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetDamageEquipmentReportByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getDamageEquipmentReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDamageEquipmentReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetDamageEquipmentReportByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getDamageEquipmentReportById>>
  > = ({signal}) => getDamageEquipmentReportById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getDamageEquipmentReportById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetDamageEquipmentReportByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDamageEquipmentReportById>>
>
export type GetDamageEquipmentReportByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get damage equipment report by ID
 */
export const useGetDamageEquipmentReportByIdSuspense = <
  TData = Awaited<ReturnType<typeof getDamageEquipmentReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getDamageEquipmentReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetDamageEquipmentReportByIdSuspenseQueryOptions(
    id,
    options,
  )

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a damage equipment report by its ID
 * @summary Update a damage equipment report by ID
 */
export const updateDamageEquipmentReport = (
  id: string,
  damageEquipmentReport: BodyType<DamageEquipmentReport>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<DamageEquipmentReport>(
    {
      url: `/damageEquipmentReports/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: damageEquipmentReport,
    },
    options,
  )
}

export const getUpdateDamageEquipmentReportMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDamageEquipmentReport>>,
    TError,
    {id: string; data: BodyType<DamageEquipmentReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateDamageEquipmentReport>>,
  TError,
  {id: string; data: BodyType<DamageEquipmentReport>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateDamageEquipmentReport>>,
    {id: string; data: BodyType<DamageEquipmentReport>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateDamageEquipmentReport(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateDamageEquipmentReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateDamageEquipmentReport>>
>
export type UpdateDamageEquipmentReportMutationBody =
  BodyType<DamageEquipmentReport>
export type UpdateDamageEquipmentReportMutationError = ErrorType<void>

/**
 * @summary Update a damage equipment report by ID
 */
export const useUpdateDamageEquipmentReport = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateDamageEquipmentReport>>,
    TError,
    {id: string; data: BodyType<DamageEquipmentReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateDamageEquipmentReport>>,
  TError,
  {id: string; data: BodyType<DamageEquipmentReport>},
  TContext
> => {
  const mutationOptions = getUpdateDamageEquipmentReportMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a damage equipment report by its ID
 * @summary Delete a damage equipment report by ID
 */
export const deleteDamageEquipmentReport = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/damageEquipmentReports/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteDamageEquipmentReportMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDamageEquipmentReport>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteDamageEquipmentReport>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDamageEquipmentReport>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteDamageEquipmentReport(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteDamageEquipmentReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDamageEquipmentReport>>
>

export type DeleteDamageEquipmentReportMutationError = ErrorType<void>

/**
 * @summary Delete a damage equipment report by ID
 */
export const useDeleteDamageEquipmentReport = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDamageEquipmentReport>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteDamageEquipmentReport>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteDamageEquipmentReportMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get all employees
 */
export const getAllEmployees = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Employee[]>(
    {url: `/employees`, method: 'GET', signal},
    options,
  )
}

export const getGetAllEmployeesQueryKey = () => {
  return [`/employees`] as const
}

export const getGetAllEmployeesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllEmployees>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllEmployees>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllEmployeesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllEmployees>>> = ({
    signal,
  }) => getAllEmployees(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllEmployees>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllEmployeesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllEmployees>>
>
export type GetAllEmployeesQueryError = ErrorType<void>

/**
 * @summary Get all employees
 */
export const useGetAllEmployees = <
  TData = Awaited<ReturnType<typeof getAllEmployees>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllEmployees>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllEmployeesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllEmployeesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllEmployees>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllEmployees>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllEmployeesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllEmployees>>> = ({
    signal,
  }) => getAllEmployees(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllEmployees>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllEmployeesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllEmployees>>
>
export type GetAllEmployeesSuspenseQueryError = ErrorType<void>

/**
 * @summary Get all employees
 */
export const useGetAllEmployeesSuspense = <
  TData = Awaited<ReturnType<typeof getAllEmployees>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllEmployees>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllEmployeesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create a new employee
 */
export const createEmployee = (
  employee: BodyType<Employee>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Employee>(
    {
      url: `/employees`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: employee,
    },
    options,
  )
}

export const getCreateEmployeeMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createEmployee>>,
    TError,
    {data: BodyType<Employee>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createEmployee>>,
  TError,
  {data: BodyType<Employee>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createEmployee>>,
    {data: BodyType<Employee>}
  > = (props) => {
    const {data} = props ?? {}

    return createEmployee(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateEmployeeMutationResult = NonNullable<
  Awaited<ReturnType<typeof createEmployee>>
>
export type CreateEmployeeMutationBody = BodyType<Employee>
export type CreateEmployeeMutationError = ErrorType<void>

/**
 * @summary Create a new employee
 */
export const useCreateEmployee = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createEmployee>>,
    TError,
    {data: BodyType<Employee>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createEmployee>>,
  TError,
  {data: BodyType<Employee>},
  TContext
> => {
  const mutationOptions = getCreateEmployeeMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get employee by ID
 */
export const getEmployeeById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Employee>(
    {url: `/employees/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetEmployeeByIdQueryKey = (id: string) => {
  return [`/employees/${id}`] as const
}

export const getGetEmployeeByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getEmployeeById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEmployeeById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetEmployeeByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeeById>>> = ({
    signal,
  }) => getEmployeeById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getEmployeeById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetEmployeeByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEmployeeById>>
>
export type GetEmployeeByIdQueryError = ErrorType<void>

/**
 * @summary Get employee by ID
 */
export const useGetEmployeeById = <
  TData = Awaited<ReturnType<typeof getEmployeeById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEmployeeById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetEmployeeByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetEmployeeByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getEmployeeById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getEmployeeById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetEmployeeByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getEmployeeById>>> = ({
    signal,
  }) => getEmployeeById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getEmployeeById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetEmployeeByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEmployeeById>>
>
export type GetEmployeeByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get employee by ID
 */
export const useGetEmployeeByIdSuspense = <
  TData = Awaited<ReturnType<typeof getEmployeeById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getEmployeeById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetEmployeeByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update an employee by ID
 */
export const updateEmployee = (
  id: string,
  employee: BodyType<Employee>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Employee>(
    {
      url: `/employees/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: employee,
    },
    options,
  )
}

export const getUpdateEmployeeMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateEmployee>>,
    TError,
    {id: string; data: BodyType<Employee>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateEmployee>>,
  TError,
  {id: string; data: BodyType<Employee>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateEmployee>>,
    {id: string; data: BodyType<Employee>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateEmployee(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateEmployeeMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateEmployee>>
>
export type UpdateEmployeeMutationBody = BodyType<Employee>
export type UpdateEmployeeMutationError = ErrorType<void>

/**
 * @summary Update an employee by ID
 */
export const useUpdateEmployee = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateEmployee>>,
    TError,
    {id: string; data: BodyType<Employee>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateEmployee>>,
  TError,
  {id: string; data: BodyType<Employee>},
  TContext
> => {
  const mutationOptions = getUpdateEmployeeMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Delete an employee by ID
 */
export const deleteEmployee = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/employees/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteEmployeeMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteEmployee>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteEmployee>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteEmployee>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteEmployee(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteEmployeeMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteEmployee>>
>

export type DeleteEmployeeMutationError = ErrorType<void>

/**
 * @summary Delete an employee by ID
 */
export const useDeleteEmployee = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteEmployee>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteEmployee>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteEmployeeMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get all equipment
 */
export const getAllEquipment = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Equipment[]>(
    {url: `/equipment`, method: 'GET', signal},
    options,
  )
}

export const getGetAllEquipmentQueryKey = () => {
  return [`/equipment`] as const
}

export const getGetAllEquipmentQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllEquipment>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllEquipment>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllEquipmentQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllEquipment>>> = ({
    signal,
  }) => getAllEquipment(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllEquipment>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllEquipmentQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllEquipment>>
>
export type GetAllEquipmentQueryError = ErrorType<void>

/**
 * @summary Get all equipment
 */
export const useGetAllEquipment = <
  TData = Awaited<ReturnType<typeof getAllEquipment>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllEquipment>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllEquipmentQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllEquipmentSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllEquipment>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllEquipment>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllEquipmentQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllEquipment>>> = ({
    signal,
  }) => getAllEquipment(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllEquipment>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllEquipmentSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllEquipment>>
>
export type GetAllEquipmentSuspenseQueryError = ErrorType<void>

/**
 * @summary Get all equipment
 */
export const useGetAllEquipmentSuspense = <
  TData = Awaited<ReturnType<typeof getAllEquipment>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllEquipment>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllEquipmentSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create a new equipment
 */
export const createEquipment = (
  equipment: BodyType<Equipment>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Equipment>(
    {
      url: `/equipment`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: equipment,
    },
    options,
  )
}

export const getCreateEquipmentMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createEquipment>>,
    TError,
    {data: BodyType<Equipment>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createEquipment>>,
  TError,
  {data: BodyType<Equipment>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createEquipment>>,
    {data: BodyType<Equipment>}
  > = (props) => {
    const {data} = props ?? {}

    return createEquipment(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateEquipmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createEquipment>>
>
export type CreateEquipmentMutationBody = BodyType<Equipment>
export type CreateEquipmentMutationError = ErrorType<void>

/**
 * @summary Create a new equipment
 */
export const useCreateEquipment = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createEquipment>>,
    TError,
    {data: BodyType<Equipment>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createEquipment>>,
  TError,
  {data: BodyType<Equipment>},
  TContext
> => {
  const mutationOptions = getCreateEquipmentMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get equipment by ID
 */
export const getEquipmentById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Equipment>(
    {url: `/equipment/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetEquipmentByIdQueryKey = (id: string) => {
  return [`/equipment/${id}`] as const
}

export const getGetEquipmentByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getEquipmentById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEquipmentById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetEquipmentByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEquipmentById>>
  > = ({signal}) => getEquipmentById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getEquipmentById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetEquipmentByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEquipmentById>>
>
export type GetEquipmentByIdQueryError = ErrorType<void>

/**
 * @summary Get equipment by ID
 */
export const useGetEquipmentById = <
  TData = Awaited<ReturnType<typeof getEquipmentById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getEquipmentById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetEquipmentByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetEquipmentByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getEquipmentById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getEquipmentById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetEquipmentByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getEquipmentById>>
  > = ({signal}) => getEquipmentById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getEquipmentById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetEquipmentByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getEquipmentById>>
>
export type GetEquipmentByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get equipment by ID
 */
export const useGetEquipmentByIdSuspense = <
  TData = Awaited<ReturnType<typeof getEquipmentById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getEquipmentById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetEquipmentByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update equipment by ID
 */
export const updateEquipment = (
  id: string,
  equipment: BodyType<Equipment>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Equipment>(
    {
      url: `/equipment/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: equipment,
    },
    options,
  )
}

export const getUpdateEquipmentMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateEquipment>>,
    TError,
    {id: string; data: BodyType<Equipment>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateEquipment>>,
  TError,
  {id: string; data: BodyType<Equipment>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateEquipment>>,
    {id: string; data: BodyType<Equipment>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateEquipment(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateEquipmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateEquipment>>
>
export type UpdateEquipmentMutationBody = BodyType<Equipment>
export type UpdateEquipmentMutationError = ErrorType<void>

/**
 * @summary Update equipment by ID
 */
export const useUpdateEquipment = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateEquipment>>,
    TError,
    {id: string; data: BodyType<Equipment>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateEquipment>>,
  TError,
  {id: string; data: BodyType<Equipment>},
  TContext
> => {
  const mutationOptions = getUpdateEquipmentMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Delete equipment by ID
 */
export const deleteEquipment = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/equipment/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteEquipmentMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteEquipment>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteEquipment>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteEquipment>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteEquipment(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteEquipmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteEquipment>>
>

export type DeleteEquipmentMutationError = ErrorType<void>

/**
 * @summary Delete equipment by ID
 */
export const useDeleteEquipment = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteEquipment>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteEquipment>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteEquipmentMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all project galleries
 * @summary Get all galleries
 */
export const getAllGalleries = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Gallery[]>(
    {url: `/galleries`, method: 'GET', signal},
    options,
  )
}

export const getGetAllGalleriesQueryKey = () => {
  return [`/galleries`] as const
}

export const getGetAllGalleriesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllGalleries>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllGalleries>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllGalleriesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllGalleries>>> = ({
    signal,
  }) => getAllGalleries(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllGalleries>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllGalleriesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllGalleries>>
>
export type GetAllGalleriesQueryError = ErrorType<unknown>

/**
 * @summary Get all galleries
 */
export const useGetAllGalleries = <
  TData = Awaited<ReturnType<typeof getAllGalleries>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllGalleries>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllGalleriesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllGalleriesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllGalleries>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllGalleries>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllGalleriesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllGalleries>>> = ({
    signal,
  }) => getAllGalleries(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllGalleries>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllGalleriesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllGalleries>>
>
export type GetAllGalleriesSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all galleries
 */
export const useGetAllGalleriesSuspense = <
  TData = Awaited<ReturnType<typeof getAllGalleries>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllGalleries>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllGalleriesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new project gallery with the provided data
 * @summary Create a new gallery
 */
export const createGallery = (
  gallery: BodyType<Gallery>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Gallery>(
    {
      url: `/galleries`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: gallery,
    },
    options,
  )
}

export const getCreateGalleryMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createGallery>>,
    TError,
    {data: BodyType<Gallery>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createGallery>>,
  TError,
  {data: BodyType<Gallery>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createGallery>>,
    {data: BodyType<Gallery>}
  > = (props) => {
    const {data} = props ?? {}

    return createGallery(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateGalleryMutationResult = NonNullable<
  Awaited<ReturnType<typeof createGallery>>
>
export type CreateGalleryMutationBody = BodyType<Gallery>
export type CreateGalleryMutationError = ErrorType<unknown>

/**
 * @summary Create a new gallery
 */
export const useCreateGallery = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createGallery>>,
    TError,
    {data: BodyType<Gallery>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createGallery>>,
  TError,
  {data: BodyType<Gallery>},
  TContext
> => {
  const mutationOptions = getCreateGalleryMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a project gallery by its ID
 * @summary Get gallery by ID
 */
export const getGalleryById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Gallery>(
    {url: `/galleries/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetGalleryByIdQueryKey = (id: string) => {
  return [`/galleries/${id}`] as const
}

export const getGetGalleryByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getGalleryById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGalleryById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGalleryByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGalleryById>>> = ({
    signal,
  }) => getGalleryById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getGalleryById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetGalleryByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGalleryById>>
>
export type GetGalleryByIdQueryError = ErrorType<void>

/**
 * @summary Get gallery by ID
 */
export const useGetGalleryById = <
  TData = Awaited<ReturnType<typeof getGalleryById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getGalleryById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetGalleryByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetGalleryByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getGalleryById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGalleryById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetGalleryByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getGalleryById>>> = ({
    signal,
  }) => getGalleryById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getGalleryById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetGalleryByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getGalleryById>>
>
export type GetGalleryByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get gallery by ID
 */
export const useGetGalleryByIdSuspense = <
  TData = Awaited<ReturnType<typeof getGalleryById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getGalleryById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetGalleryByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a project gallery by its ID
 * @summary Update a gallery
 */
export const updateGallery = (
  id: string,
  gallery: BodyType<Gallery>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Gallery>(
    {
      url: `/galleries/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: gallery,
    },
    options,
  )
}

export const getUpdateGalleryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGallery>>,
    TError,
    {id: string; data: BodyType<Gallery>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateGallery>>,
  TError,
  {id: string; data: BodyType<Gallery>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateGallery>>,
    {id: string; data: BodyType<Gallery>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateGallery(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateGalleryMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateGallery>>
>
export type UpdateGalleryMutationBody = BodyType<Gallery>
export type UpdateGalleryMutationError = ErrorType<void>

/**
 * @summary Update a gallery
 */
export const useUpdateGallery = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateGallery>>,
    TError,
    {id: string; data: BodyType<Gallery>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateGallery>>,
  TError,
  {id: string; data: BodyType<Gallery>},
  TContext
> => {
  const mutationOptions = getUpdateGalleryMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a project gallery by its ID
 * @summary Delete a gallery
 */
export const deleteGallery = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/galleries/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteGalleryMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteGallery>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteGallery>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteGallery>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteGallery(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteGalleryMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteGallery>>
>

export type DeleteGalleryMutationError = ErrorType<void>

/**
 * @summary Delete a gallery
 */
export const useDeleteGallery = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteGallery>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteGallery>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteGalleryMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Home page
 */
export const getHomePage = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<void>({url: `/`, method: 'GET', signal}, options)
}

export const getGetHomePageQueryKey = () => {
  return [`/`] as const
}

export const getGetHomePageQueryOptions = <
  TData = Awaited<ReturnType<typeof getHomePage>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getHomePage>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetHomePageQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHomePage>>> = ({
    signal,
  }) => getHomePage(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getHomePage>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetHomePageQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHomePage>>
>
export type GetHomePageQueryError = ErrorType<void>

/**
 * @summary Home page
 */
export const useGetHomePage = <
  TData = Awaited<ReturnType<typeof getHomePage>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getHomePage>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetHomePageQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetHomePageSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getHomePage>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getHomePage>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetHomePageQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getHomePage>>> = ({
    signal,
  }) => getHomePage(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getHomePage>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetHomePageSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getHomePage>>
>
export type GetHomePageSuspenseQueryError = ErrorType<void>

/**
 * @summary Home page
 */
export const useGetHomePageSuspense = <
  TData = Awaited<ReturnType<typeof getHomePage>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getHomePage>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetHomePageSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieve an injury employee report by its ID
 * @summary Get injury employee report by ID
 */
export const getInjuryEmployeeReportById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<InjuryEmployeeReport>(
    {url: `/injuryEmployeeReports/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetInjuryEmployeeReportByIdQueryKey = (id: string) => {
  return [`/injuryEmployeeReports/${id}`] as const
}

export const getGetInjuryEmployeeReportByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getInjuryEmployeeReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInjuryEmployeeReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetInjuryEmployeeReportByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInjuryEmployeeReportById>>
  > = ({signal}) => getInjuryEmployeeReportById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getInjuryEmployeeReportById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetInjuryEmployeeReportByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInjuryEmployeeReportById>>
>
export type GetInjuryEmployeeReportByIdQueryError = ErrorType<void>

/**
 * @summary Get injury employee report by ID
 */
export const useGetInjuryEmployeeReportById = <
  TData = Awaited<ReturnType<typeof getInjuryEmployeeReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getInjuryEmployeeReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetInjuryEmployeeReportByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetInjuryEmployeeReportByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getInjuryEmployeeReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getInjuryEmployeeReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetInjuryEmployeeReportByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getInjuryEmployeeReportById>>
  > = ({signal}) => getInjuryEmployeeReportById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getInjuryEmployeeReportById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetInjuryEmployeeReportByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getInjuryEmployeeReportById>>
>
export type GetInjuryEmployeeReportByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get injury employee report by ID
 */
export const useGetInjuryEmployeeReportByIdSuspense = <
  TData = Awaited<ReturnType<typeof getInjuryEmployeeReportById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getInjuryEmployeeReportById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetInjuryEmployeeReportByIdSuspenseQueryOptions(
    id,
    options,
  )

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update an injury employee report by its ID
 * @summary Update an injury employee report
 */
export const updateInjuryEmployeeReport = (
  id: string,
  injuryEmployeeReport: BodyType<InjuryEmployeeReport>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<InjuryEmployeeReport>(
    {
      url: `/injuryEmployeeReports/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: injuryEmployeeReport,
    },
    options,
  )
}

export const getUpdateInjuryEmployeeReportMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInjuryEmployeeReport>>,
    TError,
    {id: string; data: BodyType<InjuryEmployeeReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateInjuryEmployeeReport>>,
  TError,
  {id: string; data: BodyType<InjuryEmployeeReport>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateInjuryEmployeeReport>>,
    {id: string; data: BodyType<InjuryEmployeeReport>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateInjuryEmployeeReport(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateInjuryEmployeeReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateInjuryEmployeeReport>>
>
export type UpdateInjuryEmployeeReportMutationBody =
  BodyType<InjuryEmployeeReport>
export type UpdateInjuryEmployeeReportMutationError = ErrorType<void>

/**
 * @summary Update an injury employee report
 */
export const useUpdateInjuryEmployeeReport = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateInjuryEmployeeReport>>,
    TError,
    {id: string; data: BodyType<InjuryEmployeeReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateInjuryEmployeeReport>>,
  TError,
  {id: string; data: BodyType<InjuryEmployeeReport>},
  TContext
> => {
  const mutationOptions = getUpdateInjuryEmployeeReportMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete an injury employee report by its ID
 * @summary Delete an injury employee report
 */
export const deleteInjuryEmployeeReport = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/injuryEmployeeReports/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteInjuryEmployeeReportMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteInjuryEmployeeReport>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteInjuryEmployeeReport>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteInjuryEmployeeReport>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteInjuryEmployeeReport(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteInjuryEmployeeReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteInjuryEmployeeReport>>
>

export type DeleteInjuryEmployeeReportMutationError = ErrorType<unknown>

/**
 * @summary Delete an injury employee report
 */
export const useDeleteInjuryEmployeeReport = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteInjuryEmployeeReport>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteInjuryEmployeeReport>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteInjuryEmployeeReportMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all injury employee reports
 * @summary Get all injury employee reports
 */
export const getAllInjuryEmployeeReports = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<InjuryEmployeeReport[]>(
    {url: `/injuryEmployeeReports`, method: 'GET', signal},
    options,
  )
}

export const getGetAllInjuryEmployeeReportsQueryKey = () => {
  return [`/injuryEmployeeReports`] as const
}

export const getGetAllInjuryEmployeeReportsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllInjuryEmployeeReportsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>
  > = ({signal}) => getAllInjuryEmployeeReports(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllInjuryEmployeeReportsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>
>
export type GetAllInjuryEmployeeReportsQueryError = ErrorType<unknown>

/**
 * @summary Get all injury employee reports
 */
export const useGetAllInjuryEmployeeReports = <
  TData = Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllInjuryEmployeeReportsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllInjuryEmployeeReportsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllInjuryEmployeeReportsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>
  > = ({signal}) => getAllInjuryEmployeeReports(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllInjuryEmployeeReportsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>
>
export type GetAllInjuryEmployeeReportsSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all injury employee reports
 */
export const useGetAllInjuryEmployeeReportsSuspense = <
  TData = Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllInjuryEmployeeReports>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions =
    getGetAllInjuryEmployeeReportsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new injury employee report with the provided data
 * @summary Create a new injury employee report
 */
export const createInjuryEmployeeReport = (
  injuryEmployeeReport: BodyType<InjuryEmployeeReport>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<InjuryEmployeeReport>(
    {
      url: `/injuryEmployeeReports`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: injuryEmployeeReport,
    },
    options,
  )
}

export const getCreateInjuryEmployeeReportMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createInjuryEmployeeReport>>,
    TError,
    {data: BodyType<InjuryEmployeeReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createInjuryEmployeeReport>>,
  TError,
  {data: BodyType<InjuryEmployeeReport>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createInjuryEmployeeReport>>,
    {data: BodyType<InjuryEmployeeReport>}
  > = (props) => {
    const {data} = props ?? {}

    return createInjuryEmployeeReport(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateInjuryEmployeeReportMutationResult = NonNullable<
  Awaited<ReturnType<typeof createInjuryEmployeeReport>>
>
export type CreateInjuryEmployeeReportMutationBody =
  BodyType<InjuryEmployeeReport>
export type CreateInjuryEmployeeReportMutationError = ErrorType<unknown>

/**
 * @summary Create a new injury employee report
 */
export const useCreateInjuryEmployeeReport = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createInjuryEmployeeReport>>,
    TError,
    {data: BodyType<InjuryEmployeeReport>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createInjuryEmployeeReport>>,
  TError,
  {data: BodyType<InjuryEmployeeReport>},
  TContext
> => {
  const mutationOptions = getCreateInjuryEmployeeReportMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get all jobs
 */
export const getAllJobs = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Job[]>({url: `/jobs`, method: 'GET', signal}, options)
}

export const getGetAllJobsQueryKey = () => {
  return [`/jobs`] as const
}

export const getGetAllJobsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllJobs>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllJobs>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllJobsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllJobs>>> = ({
    signal,
  }) => getAllJobs(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllJobs>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllJobsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllJobs>>
>
export type GetAllJobsQueryError = ErrorType<void>

/**
 * @summary Get all jobs
 */
export const useGetAllJobs = <
  TData = Awaited<ReturnType<typeof getAllJobs>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllJobs>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllJobsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllJobsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllJobs>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllJobs>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllJobsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllJobs>>> = ({
    signal,
  }) => getAllJobs(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllJobs>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllJobsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllJobs>>
>
export type GetAllJobsSuspenseQueryError = ErrorType<void>

/**
 * @summary Get all jobs
 */
export const useGetAllJobsSuspense = <
  TData = Awaited<ReturnType<typeof getAllJobs>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllJobs>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllJobsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create a new job
 */
export const createJob = (
  job: BodyType<Job>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Job>(
    {
      url: `/jobs`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: job,
    },
    options,
  )
}

export const getCreateJobMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createJob>>,
    TError,
    {data: BodyType<Job>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createJob>>,
  TError,
  {data: BodyType<Job>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createJob>>,
    {data: BodyType<Job>}
  > = (props) => {
    const {data} = props ?? {}

    return createJob(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateJobMutationResult = NonNullable<
  Awaited<ReturnType<typeof createJob>>
>
export type CreateJobMutationBody = BodyType<Job>
export type CreateJobMutationError = ErrorType<void>

/**
 * @summary Create a new job
 */
export const useCreateJob = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createJob>>,
    TError,
    {data: BodyType<Job>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createJob>>,
  TError,
  {data: BodyType<Job>},
  TContext
> => {
  const mutationOptions = getCreateJobMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get job by ID
 */
export const getJobById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Job>(
    {url: `/jobs/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetJobByIdQueryKey = (id: string) => {
  return [`/jobs/${id}`] as const
}

export const getGetJobByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getJobById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getJobById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetJobByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getJobById>>> = ({
    signal,
  }) => getJobById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getJobById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetJobByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getJobById>>
>
export type GetJobByIdQueryError = ErrorType<void>

/**
 * @summary Get job by ID
 */
export const useGetJobById = <
  TData = Awaited<ReturnType<typeof getJobById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getJobById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetJobByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetJobByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getJobById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getJobById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetJobByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getJobById>>> = ({
    signal,
  }) => getJobById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getJobById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetJobByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getJobById>>
>
export type GetJobByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get job by ID
 */
export const useGetJobByIdSuspense = <
  TData = Awaited<ReturnType<typeof getJobById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getJobById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetJobByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update a job by ID
 */
export const updateJob = (
  id: string,
  job: BodyType<Job>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Job>(
    {
      url: `/jobs/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: job,
    },
    options,
  )
}

export const getUpdateJobMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateJob>>,
    TError,
    {id: string; data: BodyType<Job>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateJob>>,
  TError,
  {id: string; data: BodyType<Job>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateJob>>,
    {id: string; data: BodyType<Job>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateJob(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateJobMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateJob>>
>
export type UpdateJobMutationBody = BodyType<Job>
export type UpdateJobMutationError = ErrorType<void>

/**
 * @summary Update a job by ID
 */
export const useUpdateJob = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateJob>>,
    TError,
    {id: string; data: BodyType<Job>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateJob>>,
  TError,
  {id: string; data: BodyType<Job>},
  TContext
> => {
  const mutationOptions = getUpdateJobMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Delete a job by ID
 */
export const deleteJob = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>({url: `/jobs/${id}`, method: 'DELETE'}, options)
}

export const getDeleteJobMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteJob>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteJob>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteJob>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteJob(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteJobMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteJob>>
>

export type DeleteJobMutationError = ErrorType<void>

/**
 * @summary Delete a job by ID
 */
export const useDeleteJob = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteJob>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteJob>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteJobMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a material by its ID
 * @summary Get material by ID
 */
export const getMaterialById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Material>(
    {url: `/materials/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetMaterialByIdQueryKey = (id: string) => {
  return [`/materials/${id}`] as const
}

export const getGetMaterialByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getMaterialById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMaterialById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetMaterialByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialById>>> = ({
    signal,
  }) => getMaterialById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getMaterialById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetMaterialByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMaterialById>>
>
export type GetMaterialByIdQueryError = ErrorType<void>

/**
 * @summary Get material by ID
 */
export const useGetMaterialById = <
  TData = Awaited<ReturnType<typeof getMaterialById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getMaterialById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetMaterialByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetMaterialByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getMaterialById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMaterialById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetMaterialByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getMaterialById>>> = ({
    signal,
  }) => getMaterialById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getMaterialById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetMaterialByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getMaterialById>>
>
export type GetMaterialByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get material by ID
 */
export const useGetMaterialByIdSuspense = <
  TData = Awaited<ReturnType<typeof getMaterialById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getMaterialById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetMaterialByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a material by its ID
 * @summary Update a material
 */
export const updateMaterial = (
  id: string,
  material: BodyType<Material>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Material>(
    {
      url: `/materials/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: material,
    },
    options,
  )
}

export const getUpdateMaterialMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMaterial>>,
    TError,
    {id: string; data: BodyType<Material>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateMaterial>>,
  TError,
  {id: string; data: BodyType<Material>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateMaterial>>,
    {id: string; data: BodyType<Material>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateMaterial(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateMaterialMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateMaterial>>
>
export type UpdateMaterialMutationBody = BodyType<Material>
export type UpdateMaterialMutationError = ErrorType<void>

/**
 * @summary Update a material
 */
export const useUpdateMaterial = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateMaterial>>,
    TError,
    {id: string; data: BodyType<Material>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateMaterial>>,
  TError,
  {id: string; data: BodyType<Material>},
  TContext
> => {
  const mutationOptions = getUpdateMaterialMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a material by its ID
 * @summary Delete a material
 */
export const deleteMaterial = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/materials/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteMaterialMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMaterial>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteMaterial>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteMaterial>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteMaterial(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteMaterialMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteMaterial>>
>

export type DeleteMaterialMutationError = ErrorType<unknown>

/**
 * @summary Delete a material
 */
export const useDeleteMaterial = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteMaterial>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteMaterial>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteMaterialMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all materials
 * @summary Get all materials
 */
export const getAllMaterials = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Material[]>(
    {url: `/materials`, method: 'GET', signal},
    options,
  )
}

export const getGetAllMaterialsQueryKey = () => {
  return [`/materials`] as const
}

export const getGetAllMaterialsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllMaterials>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllMaterials>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllMaterialsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllMaterials>>> = ({
    signal,
  }) => getAllMaterials(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllMaterials>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllMaterialsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllMaterials>>
>
export type GetAllMaterialsQueryError = ErrorType<unknown>

/**
 * @summary Get all materials
 */
export const useGetAllMaterials = <
  TData = Awaited<ReturnType<typeof getAllMaterials>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllMaterials>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllMaterialsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllMaterialsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllMaterials>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllMaterials>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllMaterialsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllMaterials>>> = ({
    signal,
  }) => getAllMaterials(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllMaterials>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllMaterialsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllMaterials>>
>
export type GetAllMaterialsSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all materials
 */
export const useGetAllMaterialsSuspense = <
  TData = Awaited<ReturnType<typeof getAllMaterials>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllMaterials>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllMaterialsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new material with the provided data
 * @summary Create a new material
 */
export const createMaterial = (
  material: BodyType<Material>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Material>(
    {
      url: `/materials`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: material,
    },
    options,
  )
}

export const getCreateMaterialMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMaterial>>,
    TError,
    {data: BodyType<Material>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createMaterial>>,
  TError,
  {data: BodyType<Material>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createMaterial>>,
    {data: BodyType<Material>}
  > = (props) => {
    const {data} = props ?? {}

    return createMaterial(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateMaterialMutationResult = NonNullable<
  Awaited<ReturnType<typeof createMaterial>>
>
export type CreateMaterialMutationBody = BodyType<Material>
export type CreateMaterialMutationError = ErrorType<unknown>

/**
 * @summary Create a new material
 */
export const useCreateMaterial = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createMaterial>>,
    TError,
    {data: BodyType<Material>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createMaterial>>,
  TError,
  {data: BodyType<Material>},
  TContext
> => {
  const mutationOptions = getCreateMaterialMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get all operators
 */
export const getAllOperators = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Operator[]>(
    {url: `/operators`, method: 'GET', signal},
    options,
  )
}

export const getGetAllOperatorsQueryKey = () => {
  return [`/operators`] as const
}

export const getGetAllOperatorsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllOperators>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllOperators>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllOperatorsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllOperators>>> = ({
    signal,
  }) => getAllOperators(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllOperators>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllOperatorsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllOperators>>
>
export type GetAllOperatorsQueryError = ErrorType<void>

/**
 * @summary Get all operators
 */
export const useGetAllOperators = <
  TData = Awaited<ReturnType<typeof getAllOperators>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllOperators>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllOperatorsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllOperatorsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllOperators>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllOperators>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllOperatorsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllOperators>>> = ({
    signal,
  }) => getAllOperators(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllOperators>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllOperatorsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllOperators>>
>
export type GetAllOperatorsSuspenseQueryError = ErrorType<void>

/**
 * @summary Get all operators
 */
export const useGetAllOperatorsSuspense = <
  TData = Awaited<ReturnType<typeof getAllOperators>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllOperators>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllOperatorsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Create a new operator
 */
export const createOperator = (
  operator: BodyType<Operator>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Operator>(
    {
      url: `/operators`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: operator,
    },
    options,
  )
}

export const getCreateOperatorMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createOperator>>,
    TError,
    {data: BodyType<Operator>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createOperator>>,
  TError,
  {data: BodyType<Operator>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createOperator>>,
    {data: BodyType<Operator>}
  > = (props) => {
    const {data} = props ?? {}

    return createOperator(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateOperatorMutationResult = NonNullable<
  Awaited<ReturnType<typeof createOperator>>
>
export type CreateOperatorMutationBody = BodyType<Operator>
export type CreateOperatorMutationError = ErrorType<void>

/**
 * @summary Create a new operator
 */
export const useCreateOperator = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createOperator>>,
    TError,
    {data: BodyType<Operator>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createOperator>>,
  TError,
  {data: BodyType<Operator>},
  TContext
> => {
  const mutationOptions = getCreateOperatorMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Get operator by ID
 */
export const getOperatorById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Operator>(
    {url: `/operators/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetOperatorByIdQueryKey = (id: string) => {
  return [`/operators/${id}`] as const
}

export const getGetOperatorByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getOperatorById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOperatorById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOperatorByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOperatorById>>> = ({
    signal,
  }) => getOperatorById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getOperatorById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetOperatorByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOperatorById>>
>
export type GetOperatorByIdQueryError = ErrorType<void>

/**
 * @summary Get operator by ID
 */
export const useGetOperatorById = <
  TData = Awaited<ReturnType<typeof getOperatorById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getOperatorById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetOperatorByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetOperatorByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getOperatorById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getOperatorById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOperatorByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOperatorById>>> = ({
    signal,
  }) => getOperatorById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getOperatorById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetOperatorByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOperatorById>>
>
export type GetOperatorByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get operator by ID
 */
export const useGetOperatorByIdSuspense = <
  TData = Awaited<ReturnType<typeof getOperatorById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getOperatorById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetOperatorByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * @summary Update an operator by ID
 */
export const updateOperator = (
  id: string,
  operator: BodyType<Operator>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Operator>(
    {
      url: `/operators/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: operator,
    },
    options,
  )
}

export const getUpdateOperatorMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateOperator>>,
    TError,
    {id: string; data: BodyType<Operator>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateOperator>>,
  TError,
  {id: string; data: BodyType<Operator>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateOperator>>,
    {id: string; data: BodyType<Operator>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateOperator(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateOperatorMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateOperator>>
>
export type UpdateOperatorMutationBody = BodyType<Operator>
export type UpdateOperatorMutationError = ErrorType<void>

/**
 * @summary Update an operator by ID
 */
export const useUpdateOperator = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateOperator>>,
    TError,
    {id: string; data: BodyType<Operator>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateOperator>>,
  TError,
  {id: string; data: BodyType<Operator>},
  TContext
> => {
  const mutationOptions = getUpdateOperatorMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * @summary Delete an operator by ID
 */
export const deleteOperator = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/operators/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteOperatorMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteOperator>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteOperator>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteOperator>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteOperator(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteOperatorMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteOperator>>
>

export type DeleteOperatorMutationError = ErrorType<void>

/**
 * @summary Delete an operator by ID
 */
export const useDeleteOperator = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteOperator>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteOperator>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteOperatorMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all permissions
 * @summary Get all permissions
 */
export const getAllPermissions = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Permission[]>(
    {url: `/permissions`, method: 'GET', signal},
    options,
  )
}

export const getGetAllPermissionsQueryKey = () => {
  return [`/permissions`] as const
}

export const getGetAllPermissionsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllPermissions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllPermissions>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllPermissionsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllPermissions>>
  > = ({signal}) => getAllPermissions(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllPermissions>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllPermissionsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllPermissions>>
>
export type GetAllPermissionsQueryError = ErrorType<unknown>

/**
 * @summary Get all permissions
 */
export const useGetAllPermissions = <
  TData = Awaited<ReturnType<typeof getAllPermissions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllPermissions>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllPermissionsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllPermissionsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllPermissions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllPermissions>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllPermissionsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllPermissions>>
  > = ({signal}) => getAllPermissions(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllPermissions>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllPermissionsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllPermissions>>
>
export type GetAllPermissionsSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all permissions
 */
export const useGetAllPermissionsSuspense = <
  TData = Awaited<ReturnType<typeof getAllPermissions>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllPermissions>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllPermissionsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new permission with the provided data
 * @summary Create a new permission
 */
export const createPermission = (
  permission: BodyType<Permission>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Permission>(
    {
      url: `/permissions`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: permission,
    },
    options,
  )
}

export const getCreatePermissionMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPermission>>,
    TError,
    {data: BodyType<Permission>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createPermission>>,
  TError,
  {data: BodyType<Permission>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createPermission>>,
    {data: BodyType<Permission>}
  > = (props) => {
    const {data} = props ?? {}

    return createPermission(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreatePermissionMutationResult = NonNullable<
  Awaited<ReturnType<typeof createPermission>>
>
export type CreatePermissionMutationBody = BodyType<Permission>
export type CreatePermissionMutationError = ErrorType<unknown>

/**
 * @summary Create a new permission
 */
export const useCreatePermission = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createPermission>>,
    TError,
    {data: BodyType<Permission>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createPermission>>,
  TError,
  {data: BodyType<Permission>},
  TContext
> => {
  const mutationOptions = getCreatePermissionMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a permission by its ID
 * @summary Get permission by ID
 */
export const getPermissionById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Permission>(
    {url: `/permissions/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetPermissionByIdQueryKey = (id: string) => {
  return [`/permissions/${id}`] as const
}

export const getGetPermissionByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getPermissionById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPermissionById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPermissionByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPermissionById>>
  > = ({signal}) => getPermissionById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getPermissionById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetPermissionByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPermissionById>>
>
export type GetPermissionByIdQueryError = ErrorType<void>

/**
 * @summary Get permission by ID
 */
export const useGetPermissionById = <
  TData = Awaited<ReturnType<typeof getPermissionById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getPermissionById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetPermissionByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetPermissionByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getPermissionById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getPermissionById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetPermissionByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getPermissionById>>
  > = ({signal}) => getPermissionById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getPermissionById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetPermissionByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getPermissionById>>
>
export type GetPermissionByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get permission by ID
 */
export const useGetPermissionByIdSuspense = <
  TData = Awaited<ReturnType<typeof getPermissionById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getPermissionById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetPermissionByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a permission by its ID
 * @summary Update a permission
 */
export const updatePermission = (
  id: string,
  permission: BodyType<Permission>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Permission>(
    {
      url: `/permissions/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: permission,
    },
    options,
  )
}

export const getUpdatePermissionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePermission>>,
    TError,
    {id: string; data: BodyType<Permission>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePermission>>,
  TError,
  {id: string; data: BodyType<Permission>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePermission>>,
    {id: string; data: BodyType<Permission>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updatePermission(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdatePermissionMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePermission>>
>
export type UpdatePermissionMutationBody = BodyType<Permission>
export type UpdatePermissionMutationError = ErrorType<void>

/**
 * @summary Update a permission
 */
export const useUpdatePermission = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePermission>>,
    TError,
    {id: string; data: BodyType<Permission>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updatePermission>>,
  TError,
  {id: string; data: BodyType<Permission>},
  TContext
> => {
  const mutationOptions = getUpdatePermissionMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a permission by its ID
 * @summary Delete a permission
 */
export const deletePermission = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/permissions/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeletePermissionMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePermission>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePermission>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deletePermission>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deletePermission(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeletePermissionMutationResult = NonNullable<
  Awaited<ReturnType<typeof deletePermission>>
>

export type DeletePermissionMutationError = ErrorType<void>

/**
 * @summary Delete a permission
 */
export const useDeletePermission = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePermission>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deletePermission>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeletePermissionMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a project assignment by its ID
 * @summary Get project assignment by ID
 */
export const getProjectAssignmentById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<ProjectAssignment>(
    {url: `/projectAssignments/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetProjectAssignmentByIdQueryKey = (id: string) => {
  return [`/projectAssignments/${id}`] as const
}

export const getGetProjectAssignmentByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectAssignmentById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectAssignmentById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProjectAssignmentByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProjectAssignmentById>>
  > = ({signal}) => getProjectAssignmentById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getProjectAssignmentById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProjectAssignmentByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectAssignmentById>>
>
export type GetProjectAssignmentByIdQueryError = ErrorType<void>

/**
 * @summary Get project assignment by ID
 */
export const useGetProjectAssignmentById = <
  TData = Awaited<ReturnType<typeof getProjectAssignmentById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectAssignmentById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProjectAssignmentByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetProjectAssignmentByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectAssignmentById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProjectAssignmentById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProjectAssignmentByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProjectAssignmentById>>
  > = ({signal}) => getProjectAssignmentById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getProjectAssignmentById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProjectAssignmentByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectAssignmentById>>
>
export type GetProjectAssignmentByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get project assignment by ID
 */
export const useGetProjectAssignmentByIdSuspense = <
  TData = Awaited<ReturnType<typeof getProjectAssignmentById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProjectAssignmentById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProjectAssignmentByIdSuspenseQueryOptions(
    id,
    options,
  )

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a project assignment by its ID
 * @summary Update a project assignment
 */
export const updateProjectAssignment = (
  id: string,
  projectAssignment: BodyType<ProjectAssignment>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<ProjectAssignment>(
    {
      url: `/projectAssignments/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: projectAssignment,
    },
    options,
  )
}

export const getUpdateProjectAssignmentMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectAssignment>>,
    TError,
    {id: string; data: BodyType<ProjectAssignment>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProjectAssignment>>,
  TError,
  {id: string; data: BodyType<ProjectAssignment>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProjectAssignment>>,
    {id: string; data: BodyType<ProjectAssignment>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateProjectAssignment(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateProjectAssignmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProjectAssignment>>
>
export type UpdateProjectAssignmentMutationBody = BodyType<ProjectAssignment>
export type UpdateProjectAssignmentMutationError = ErrorType<void>

/**
 * @summary Update a project assignment
 */
export const useUpdateProjectAssignment = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectAssignment>>,
    TError,
    {id: string; data: BodyType<ProjectAssignment>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateProjectAssignment>>,
  TError,
  {id: string; data: BodyType<ProjectAssignment>},
  TContext
> => {
  const mutationOptions = getUpdateProjectAssignmentMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a project assignment by its ID
 * @summary Delete a project assignment
 */
export const deleteProjectAssignment = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/projectAssignments/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteProjectAssignmentMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectAssignment>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProjectAssignment>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProjectAssignment>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteProjectAssignment(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteProjectAssignmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProjectAssignment>>
>

export type DeleteProjectAssignmentMutationError = ErrorType<void>

/**
 * @summary Delete a project assignment
 */
export const useDeleteProjectAssignment = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectAssignment>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteProjectAssignment>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteProjectAssignmentMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all project assignments
 * @summary Get all project assignments
 */
export const getAllProjectAssignments = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<ProjectAssignment[]>(
    {url: `/projectAssignments`, method: 'GET', signal},
    options,
  )
}

export const getGetAllProjectAssignmentsQueryKey = () => {
  return [`/projectAssignments`] as const
}

export const getGetAllProjectAssignmentsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjectAssignments>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectAssignments>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllProjectAssignmentsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllProjectAssignments>>
  > = ({signal}) => getAllProjectAssignments(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllProjectAssignments>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProjectAssignmentsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjectAssignments>>
>
export type GetAllProjectAssignmentsQueryError = ErrorType<unknown>

/**
 * @summary Get all project assignments
 */
export const useGetAllProjectAssignments = <
  TData = Awaited<ReturnType<typeof getAllProjectAssignments>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectAssignments>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProjectAssignmentsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllProjectAssignmentsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjectAssignments>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectAssignments>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllProjectAssignmentsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllProjectAssignments>>
  > = ({signal}) => getAllProjectAssignments(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllProjectAssignments>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProjectAssignmentsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjectAssignments>>
>
export type GetAllProjectAssignmentsSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all project assignments
 */
export const useGetAllProjectAssignmentsSuspense = <
  TData = Awaited<ReturnType<typeof getAllProjectAssignments>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectAssignments>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProjectAssignmentsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new project assignment with the provided data
 * @summary Create a new project assignment
 */
export const createProjectAssignment = (
  projectAssignment: BodyType<ProjectAssignment>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<ProjectAssignment>(
    {
      url: `/projectAssignments`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: projectAssignment,
    },
    options,
  )
}

export const getCreateProjectAssignmentMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectAssignment>>,
    TError,
    {data: BodyType<ProjectAssignment>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProjectAssignment>>,
  TError,
  {data: BodyType<ProjectAssignment>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProjectAssignment>>,
    {data: BodyType<ProjectAssignment>}
  > = (props) => {
    const {data} = props ?? {}

    return createProjectAssignment(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateProjectAssignmentMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProjectAssignment>>
>
export type CreateProjectAssignmentMutationBody = BodyType<ProjectAssignment>
export type CreateProjectAssignmentMutationError = ErrorType<unknown>

/**
 * @summary Create a new project assignment
 */
export const useCreateProjectAssignment = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectAssignment>>,
    TError,
    {data: BodyType<ProjectAssignment>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createProjectAssignment>>,
  TError,
  {data: BodyType<ProjectAssignment>},
  TContext
> => {
  const mutationOptions = getCreateProjectAssignmentMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a project cost by its ID
 * @summary Get project cost by ID
 */
export const getProjectCostById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<ProjectCost>(
    {url: `/projectCosts/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetProjectCostByIdQueryKey = (id: string) => {
  return [`/projectCosts/${id}`] as const
}

export const getGetProjectCostByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectCostById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectCostById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProjectCostByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProjectCostById>>
  > = ({signal}) => getProjectCostById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getProjectCostById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProjectCostByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectCostById>>
>
export type GetProjectCostByIdQueryError = ErrorType<void>

/**
 * @summary Get project cost by ID
 */
export const useGetProjectCostById = <
  TData = Awaited<ReturnType<typeof getProjectCostById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectCostById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProjectCostByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetProjectCostByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectCostById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProjectCostById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProjectCostByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProjectCostById>>
  > = ({signal}) => getProjectCostById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getProjectCostById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProjectCostByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectCostById>>
>
export type GetProjectCostByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get project cost by ID
 */
export const useGetProjectCostByIdSuspense = <
  TData = Awaited<ReturnType<typeof getProjectCostById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProjectCostById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProjectCostByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a project cost by its ID
 * @summary Update a project cost
 */
export const updateProjectCost = (
  id: string,
  projectCost: BodyType<ProjectCost>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<ProjectCost>(
    {
      url: `/projectCosts/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: projectCost,
    },
    options,
  )
}

export const getUpdateProjectCostMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectCost>>,
    TError,
    {id: string; data: BodyType<ProjectCost>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProjectCost>>,
  TError,
  {id: string; data: BodyType<ProjectCost>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProjectCost>>,
    {id: string; data: BodyType<ProjectCost>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateProjectCost(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateProjectCostMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProjectCost>>
>
export type UpdateProjectCostMutationBody = BodyType<ProjectCost>
export type UpdateProjectCostMutationError = ErrorType<void>

/**
 * @summary Update a project cost
 */
export const useUpdateProjectCost = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectCost>>,
    TError,
    {id: string; data: BodyType<ProjectCost>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateProjectCost>>,
  TError,
  {id: string; data: BodyType<ProjectCost>},
  TContext
> => {
  const mutationOptions = getUpdateProjectCostMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a project cost by its ID
 * @summary Delete a project cost
 */
export const deleteProjectCost = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/projectCosts/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteProjectCostMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectCost>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProjectCost>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProjectCost>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteProjectCost(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteProjectCostMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProjectCost>>
>

export type DeleteProjectCostMutationError = ErrorType<void>

/**
 * @summary Delete a project cost
 */
export const useDeleteProjectCost = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectCost>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteProjectCost>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteProjectCostMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all project costs
 * @summary Get all project costs
 */
export const getAllProjectCosts = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<ProjectCost[]>(
    {url: `/projectCosts`, method: 'GET', signal},
    options,
  )
}

export const getGetAllProjectCostsQueryKey = () => {
  return [`/projectCosts`] as const
}

export const getGetAllProjectCostsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjectCosts>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectCosts>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllProjectCostsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllProjectCosts>>
  > = ({signal}) => getAllProjectCosts(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllProjectCosts>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProjectCostsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjectCosts>>
>
export type GetAllProjectCostsQueryError = ErrorType<unknown>

/**
 * @summary Get all project costs
 */
export const useGetAllProjectCosts = <
  TData = Awaited<ReturnType<typeof getAllProjectCosts>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectCosts>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProjectCostsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllProjectCostsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjectCosts>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectCosts>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllProjectCostsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllProjectCosts>>
  > = ({signal}) => getAllProjectCosts(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllProjectCosts>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProjectCostsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjectCosts>>
>
export type GetAllProjectCostsSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all project costs
 */
export const useGetAllProjectCostsSuspense = <
  TData = Awaited<ReturnType<typeof getAllProjectCosts>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectCosts>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProjectCostsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new project cost with the provided data
 * @summary Create a new project cost
 */
export const createProjectCost = (
  projectCost: BodyType<ProjectCost>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<ProjectCost>(
    {
      url: `/projectCosts`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: projectCost,
    },
    options,
  )
}

export const getCreateProjectCostMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectCost>>,
    TError,
    {data: BodyType<ProjectCost>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProjectCost>>,
  TError,
  {data: BodyType<ProjectCost>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProjectCost>>,
    {data: BodyType<ProjectCost>}
  > = (props) => {
    const {data} = props ?? {}

    return createProjectCost(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateProjectCostMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProjectCost>>
>
export type CreateProjectCostMutationBody = BodyType<ProjectCost>
export type CreateProjectCostMutationError = ErrorType<unknown>

/**
 * @summary Create a new project cost
 */
export const useCreateProjectCost = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectCost>>,
    TError,
    {data: BodyType<ProjectCost>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createProjectCost>>,
  TError,
  {data: BodyType<ProjectCost>},
  TContext
> => {
  const mutationOptions = getCreateProjectCostMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a project gallery subject by its ID
 * @summary Get project gallery subject by ID
 */
export const getProjectGallerySubjectById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<ProjectGallerySubject>(
    {url: `/projectGallerySubjects/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetProjectGallerySubjectByIdQueryKey = (id: string) => {
  return [`/projectGallerySubjects/${id}`] as const
}

export const getGetProjectGallerySubjectByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectGallerySubjectById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectGallerySubjectById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProjectGallerySubjectByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProjectGallerySubjectById>>
  > = ({signal}) => getProjectGallerySubjectById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getProjectGallerySubjectById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProjectGallerySubjectByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectGallerySubjectById>>
>
export type GetProjectGallerySubjectByIdQueryError = ErrorType<void>

/**
 * @summary Get project gallery subject by ID
 */
export const useGetProjectGallerySubjectById = <
  TData = Awaited<ReturnType<typeof getProjectGallerySubjectById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectGallerySubjectById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProjectGallerySubjectByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetProjectGallerySubjectByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectGallerySubjectById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProjectGallerySubjectById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetProjectGallerySubjectByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProjectGallerySubjectById>>
  > = ({signal}) => getProjectGallerySubjectById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getProjectGallerySubjectById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProjectGallerySubjectByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectGallerySubjectById>>
>
export type GetProjectGallerySubjectByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get project gallery subject by ID
 */
export const useGetProjectGallerySubjectByIdSuspense = <
  TData = Awaited<ReturnType<typeof getProjectGallerySubjectById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProjectGallerySubjectById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProjectGallerySubjectByIdSuspenseQueryOptions(
    id,
    options,
  )

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a project gallery subject by its ID
 * @summary Update a project gallery subject
 */
export const updateProjectGallerySubject = (
  id: string,
  projectGallerySubject: BodyType<ProjectGallerySubject>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<ProjectGallerySubject>(
    {
      url: `/projectGallerySubjects/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: projectGallerySubject,
    },
    options,
  )
}

export const getUpdateProjectGallerySubjectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectGallerySubject>>,
    TError,
    {id: string; data: BodyType<ProjectGallerySubject>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProjectGallerySubject>>,
  TError,
  {id: string; data: BodyType<ProjectGallerySubject>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProjectGallerySubject>>,
    {id: string; data: BodyType<ProjectGallerySubject>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateProjectGallerySubject(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateProjectGallerySubjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProjectGallerySubject>>
>
export type UpdateProjectGallerySubjectMutationBody =
  BodyType<ProjectGallerySubject>
export type UpdateProjectGallerySubjectMutationError = ErrorType<void>

/**
 * @summary Update a project gallery subject
 */
export const useUpdateProjectGallerySubject = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProjectGallerySubject>>,
    TError,
    {id: string; data: BodyType<ProjectGallerySubject>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateProjectGallerySubject>>,
  TError,
  {id: string; data: BodyType<ProjectGallerySubject>},
  TContext
> => {
  const mutationOptions = getUpdateProjectGallerySubjectMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a project gallery subject by its ID
 * @summary Delete a project gallery subject
 */
export const deleteProjectGallerySubject = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/projectGallerySubjects/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteProjectGallerySubjectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectGallerySubject>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProjectGallerySubject>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProjectGallerySubject>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteProjectGallerySubject(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteProjectGallerySubjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProjectGallerySubject>>
>

export type DeleteProjectGallerySubjectMutationError = ErrorType<void>

/**
 * @summary Delete a project gallery subject
 */
export const useDeleteProjectGallerySubject = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProjectGallerySubject>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteProjectGallerySubject>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteProjectGallerySubjectMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all project gallery subjects
 * @summary Get all project gallery subjects
 */
export const getAllProjectGallerySubjects = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<ProjectGallerySubject[]>(
    {url: `/projectGallerySubjects`, method: 'GET', signal},
    options,
  )
}

export const getGetAllProjectGallerySubjectsQueryKey = () => {
  return [`/projectGallerySubjects`] as const
}

export const getGetAllProjectGallerySubjectsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjectGallerySubjects>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectGallerySubjects>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllProjectGallerySubjectsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllProjectGallerySubjects>>
  > = ({signal}) => getAllProjectGallerySubjects(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllProjectGallerySubjects>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProjectGallerySubjectsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjectGallerySubjects>>
>
export type GetAllProjectGallerySubjectsQueryError = ErrorType<unknown>

/**
 * @summary Get all project gallery subjects
 */
export const useGetAllProjectGallerySubjects = <
  TData = Awaited<ReturnType<typeof getAllProjectGallerySubjects>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectGallerySubjects>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProjectGallerySubjectsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllProjectGallerySubjectsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjectGallerySubjects>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectGallerySubjects>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllProjectGallerySubjectsQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllProjectGallerySubjects>>
  > = ({signal}) => getAllProjectGallerySubjects(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllProjectGallerySubjects>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProjectGallerySubjectsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjectGallerySubjects>>
>
export type GetAllProjectGallerySubjectsSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all project gallery subjects
 */
export const useGetAllProjectGallerySubjectsSuspense = <
  TData = Awaited<ReturnType<typeof getAllProjectGallerySubjects>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectGallerySubjects>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions =
    getGetAllProjectGallerySubjectsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new project gallery subject with the provided data
 * @summary Create a new project gallery subject
 */
export const createProjectGallerySubject = (
  projectGallerySubject: BodyType<ProjectGallerySubject>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<ProjectGallerySubject>(
    {
      url: `/projectGallerySubjects`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: projectGallerySubject,
    },
    options,
  )
}

export const getCreateProjectGallerySubjectMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectGallerySubject>>,
    TError,
    {data: BodyType<ProjectGallerySubject>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProjectGallerySubject>>,
  TError,
  {data: BodyType<ProjectGallerySubject>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProjectGallerySubject>>,
    {data: BodyType<ProjectGallerySubject>}
  > = (props) => {
    const {data} = props ?? {}

    return createProjectGallerySubject(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateProjectGallerySubjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProjectGallerySubject>>
>
export type CreateProjectGallerySubjectMutationBody =
  BodyType<ProjectGallerySubject>
export type CreateProjectGallerySubjectMutationError = ErrorType<unknown>

/**
 * @summary Create a new project gallery subject
 */
export const useCreateProjectGallerySubject = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProjectGallerySubject>>,
    TError,
    {data: BodyType<ProjectGallerySubject>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createProjectGallerySubject>>,
  TError,
  {data: BodyType<ProjectGallerySubject>},
  TContext
> => {
  const mutationOptions = getCreateProjectGallerySubjectMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all projects
 * @summary Get all projects
 */
export const getAllProjects = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Project[]>(
    {url: `/projects`, method: 'GET', signal},
    options,
  )
}

export const getGetAllProjectsQueryKey = () => {
  return [`/projects`] as const
}

export const getGetAllProjectsQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjects>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllProjects>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllProjectsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProjects>>> = ({
    signal,
  }) => getAllProjects(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllProjects>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProjectsQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjects>>
>
export type GetAllProjectsQueryError = ErrorType<unknown>

/**
 * @summary Get all projects
 */
export const useGetAllProjects = <
  TData = Awaited<ReturnType<typeof getAllProjects>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllProjects>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProjectsQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllProjectsSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjects>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProjects>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllProjectsQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProjects>>> = ({
    signal,
  }) => getAllProjects(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllProjects>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProjectsSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjects>>
>
export type GetAllProjectsSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all projects
 */
export const useGetAllProjectsSuspense = <
  TData = Awaited<ReturnType<typeof getAllProjects>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProjects>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProjectsSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new project with the provided data
 * @summary Create a new project
 */
export const createProject = (
  project: BodyType<Project>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Project>(
    {
      url: `/projects`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: project,
    },
    options,
  )
}

export const getCreateProjectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProject>>,
    TError,
    {data: BodyType<Project>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProject>>,
  TError,
  {data: BodyType<Project>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProject>>,
    {data: BodyType<Project>}
  > = (props) => {
    const {data} = props ?? {}

    return createProject(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProject>>
>
export type CreateProjectMutationBody = BodyType<Project>
export type CreateProjectMutationError = ErrorType<void>

/**
 * @summary Create a new project
 */
export const useCreateProject = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProject>>,
    TError,
    {data: BodyType<Project>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createProject>>,
  TError,
  {data: BodyType<Project>},
  TContext
> => {
  const mutationOptions = getCreateProjectMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a project by its ID
 * @summary Get project by ID
 */
export const getProjectById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Project>(
    {url: `/projects/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetProjectByIdQueryKey = (id: string) => {
  return [`/projects/${id}`] as const
}

export const getGetProjectByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProjectByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectById>>> = ({
    signal,
  }) => getProjectById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getProjectById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProjectByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectById>>
>
export type GetProjectByIdQueryError = ErrorType<void>

/**
 * @summary Get project by ID
 */
export const useGetProjectById = <
  TData = Awaited<ReturnType<typeof getProjectById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getProjectById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProjectByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetProjectByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProjectById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProjectByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProjectById>>> = ({
    signal,
  }) => getProjectById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getProjectById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProjectByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectById>>
>
export type GetProjectByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get project by ID
 */
export const useGetProjectByIdSuspense = <
  TData = Awaited<ReturnType<typeof getProjectById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProjectById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProjectByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a project by its ID
 * @summary Update a project
 */
export const updateProject = (
  id: string,
  project: BodyType<Project>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Project>(
    {
      url: `/projects/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: project,
    },
    options,
  )
}

export const getUpdateProjectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProject>>,
    TError,
    {id: string; data: BodyType<Project>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProject>>,
  TError,
  {id: string; data: BodyType<Project>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProject>>,
    {id: string; data: BodyType<Project>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateProject(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProject>>
>
export type UpdateProjectMutationBody = BodyType<Project>
export type UpdateProjectMutationError = ErrorType<void>

/**
 * @summary Update a project
 */
export const useUpdateProject = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProject>>,
    TError,
    {id: string; data: BodyType<Project>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateProject>>,
  TError,
  {id: string; data: BodyType<Project>},
  TContext
> => {
  const mutationOptions = getUpdateProjectMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Partially update a project by its ID. Only the fields provided in the request body will be updated.
 * @summary Partially update a project
 */
export const patchProject = (
  id: string,
  patchProjectBody: BodyType<PatchProjectBody>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Project>(
    {
      url: `/projects/${id}`,
      method: 'PATCH',
      headers: {'Content-Type': 'application/json'},
      data: patchProjectBody,
    },
    options,
  )
}

export const getPatchProjectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchProject>>,
    TError,
    {id: string; data: BodyType<PatchProjectBody>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof patchProject>>,
  TError,
  {id: string; data: BodyType<PatchProjectBody>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof patchProject>>,
    {id: string; data: BodyType<PatchProjectBody>}
  > = (props) => {
    const {id, data} = props ?? {}

    return patchProject(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type PatchProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof patchProject>>
>
export type PatchProjectMutationBody = BodyType<PatchProjectBody>
export type PatchProjectMutationError = ErrorType<void>

/**
 * @summary Partially update a project
 */
export const usePatchProject = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof patchProject>>,
    TError,
    {id: string; data: BodyType<PatchProjectBody>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof patchProject>>,
  TError,
  {id: string; data: BodyType<PatchProjectBody>},
  TContext
> => {
  const mutationOptions = getPatchProjectMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a project by its ID
 * @summary Delete a project
 */
export const deleteProject = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/projects/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteProjectMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProject>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProject>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProject>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteProject(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteProjectMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProject>>
>

export type DeleteProjectMutationError = ErrorType<void>

/**
 * @summary Delete a project
 */
export const useDeleteProject = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProject>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteProject>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteProjectMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve the gallery of a project by its ID
 * @summary Get project gallery by ID
 */
export const getProjectGallery = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Gallery[]>(
    {url: `/projects/${id}/gallery`, method: 'GET', signal},
    options,
  )
}

export const getGetProjectGalleryQueryKey = (id: string) => {
  return [`/projects/${id}/gallery`] as const
}

export const getGetProjectGalleryQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectGallery>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectGallery>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProjectGalleryQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProjectGallery>>
  > = ({signal}) => getProjectGallery(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getProjectGallery>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProjectGalleryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectGallery>>
>
export type GetProjectGalleryQueryError = ErrorType<void>

/**
 * @summary Get project gallery by ID
 */
export const useGetProjectGallery = <
  TData = Awaited<ReturnType<typeof getProjectGallery>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProjectGallery>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProjectGalleryQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetProjectGallerySuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getProjectGallery>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProjectGallery>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProjectGalleryQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getProjectGallery>>
  > = ({signal}) => getProjectGallery(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getProjectGallery>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProjectGallerySuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProjectGallery>>
>
export type GetProjectGallerySuspenseQueryError = ErrorType<void>

/**
 * @summary Get project gallery by ID
 */
export const useGetProjectGallerySuspense = <
  TData = Awaited<ReturnType<typeof getProjectGallery>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProjectGallery>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProjectGallerySuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieve a list of all project statuses
 * @summary Get all project statuses
 */
export const getAllProjectStatuses = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<string[]>(
    {url: `/project-statuses`, method: 'GET', signal},
    options,
  )
}

export const getGetAllProjectStatusesQueryKey = () => {
  return [`/project-statuses`] as const
}

export const getGetAllProjectStatusesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjectStatuses>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectStatuses>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllProjectStatusesQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllProjectStatuses>>
  > = ({signal}) => getAllProjectStatuses(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllProjectStatuses>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProjectStatusesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjectStatuses>>
>
export type GetAllProjectStatusesQueryError = ErrorType<unknown>

/**
 * @summary Get all project statuses
 */
export const useGetAllProjectStatuses = <
  TData = Awaited<ReturnType<typeof getAllProjectStatuses>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectStatuses>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProjectStatusesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllProjectStatusesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProjectStatuses>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectStatuses>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllProjectStatusesQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllProjectStatuses>>
  > = ({signal}) => getAllProjectStatuses(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllProjectStatuses>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProjectStatusesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProjectStatuses>>
>
export type GetAllProjectStatusesSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all project statuses
 */
export const useGetAllProjectStatusesSuspense = <
  TData = Awaited<ReturnType<typeof getAllProjectStatuses>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProjectStatuses>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProjectStatusesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieve a province by its ID
 * @summary Get province by ID
 */
export const getProvinceById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Province>(
    {url: `/provinces/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetProvinceByIdQueryKey = (id: string) => {
  return [`/provinces/${id}`] as const
}

export const getGetProvinceByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getProvinceById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProvinceById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProvinceByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProvinceById>>> = ({
    signal,
  }) => getProvinceById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getProvinceById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProvinceByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProvinceById>>
>
export type GetProvinceByIdQueryError = ErrorType<void>

/**
 * @summary Get province by ID
 */
export const useGetProvinceById = <
  TData = Awaited<ReturnType<typeof getProvinceById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getProvinceById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProvinceByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetProvinceByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getProvinceById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProvinceById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetProvinceByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getProvinceById>>> = ({
    signal,
  }) => getProvinceById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getProvinceById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetProvinceByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getProvinceById>>
>
export type GetProvinceByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get province by ID
 */
export const useGetProvinceByIdSuspense = <
  TData = Awaited<ReturnType<typeof getProvinceById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getProvinceById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetProvinceByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a province by its ID
 * @summary Update a province
 */
export const updateProvince = (
  id: string,
  province: BodyType<Province>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Province>(
    {
      url: `/provinces/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: province,
    },
    options,
  )
}

export const getUpdateProvinceMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProvince>>,
    TError,
    {id: string; data: BodyType<Province>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateProvince>>,
  TError,
  {id: string; data: BodyType<Province>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateProvince>>,
    {id: string; data: BodyType<Province>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateProvince(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateProvinceMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateProvince>>
>
export type UpdateProvinceMutationBody = BodyType<Province>
export type UpdateProvinceMutationError = ErrorType<void>

/**
 * @summary Update a province
 */
export const useUpdateProvince = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateProvince>>,
    TError,
    {id: string; data: BodyType<Province>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateProvince>>,
  TError,
  {id: string; data: BodyType<Province>},
  TContext
> => {
  const mutationOptions = getUpdateProvinceMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a province by its ID
 * @summary Delete a province
 */
export const deleteProvince = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/provinces/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteProvinceMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProvince>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteProvince>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteProvince>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteProvince(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteProvinceMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteProvince>>
>

export type DeleteProvinceMutationError = ErrorType<void>

/**
 * @summary Delete a province
 */
export const useDeleteProvince = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteProvince>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteProvince>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteProvinceMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all provinces
 * @summary Get all provinces
 */
export const getAllProvinces = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Province[]>(
    {url: `/provinces`, method: 'GET', signal},
    options,
  )
}

export const getGetAllProvincesQueryKey = () => {
  return [`/provinces`] as const
}

export const getGetAllProvincesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProvinces>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllProvinces>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllProvincesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProvinces>>> = ({
    signal,
  }) => getAllProvinces(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllProvinces>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProvincesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProvinces>>
>
export type GetAllProvincesQueryError = ErrorType<unknown>

/**
 * @summary Get all provinces
 */
export const useGetAllProvinces = <
  TData = Awaited<ReturnType<typeof getAllProvinces>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllProvinces>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProvincesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllProvincesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllProvinces>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProvinces>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllProvincesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllProvinces>>> = ({
    signal,
  }) => getAllProvinces(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllProvinces>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllProvincesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllProvinces>>
>
export type GetAllProvincesSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all provinces
 */
export const useGetAllProvincesSuspense = <
  TData = Awaited<ReturnType<typeof getAllProvinces>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllProvinces>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllProvincesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new province with the provided data
 * @summary Create a new province
 */
export const createProvince = (
  province: BodyType<Province>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Province>(
    {
      url: `/provinces`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: province,
    },
    options,
  )
}

export const getCreateProvinceMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProvince>>,
    TError,
    {data: BodyType<Province>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createProvince>>,
  TError,
  {data: BodyType<Province>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createProvince>>,
    {data: BodyType<Province>}
  > = (props) => {
    const {data} = props ?? {}

    return createProvince(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateProvinceMutationResult = NonNullable<
  Awaited<ReturnType<typeof createProvince>>
>
export type CreateProvinceMutationBody = BodyType<Province>
export type CreateProvinceMutationError = ErrorType<unknown>

/**
 * @summary Create a new province
 */
export const useCreateProvince = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createProvince>>,
    TError,
    {data: BodyType<Province>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createProvince>>,
  TError,
  {data: BodyType<Province>},
  TContext
> => {
  const mutationOptions = getCreateProvinceMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a resource by its ID
 * @summary Get resource by ID
 */
export const getResourceById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Resource>(
    {url: `/resources/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetResourceByIdQueryKey = (id: string) => {
  return [`/resources/${id}`] as const
}

export const getGetResourceByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getResourceById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getResourceById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetResourceByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getResourceById>>> = ({
    signal,
  }) => getResourceById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getResourceById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetResourceByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getResourceById>>
>
export type GetResourceByIdQueryError = ErrorType<void>

/**
 * @summary Get resource by ID
 */
export const useGetResourceById = <
  TData = Awaited<ReturnType<typeof getResourceById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getResourceById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetResourceByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetResourceByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getResourceById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getResourceById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetResourceByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getResourceById>>> = ({
    signal,
  }) => getResourceById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getResourceById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetResourceByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getResourceById>>
>
export type GetResourceByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get resource by ID
 */
export const useGetResourceByIdSuspense = <
  TData = Awaited<ReturnType<typeof getResourceById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getResourceById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetResourceByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a resource by its ID
 * @summary Update a resource
 */
export const updateResource = (
  id: string,
  resource: BodyType<Resource>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Resource>(
    {
      url: `/resources/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: resource,
    },
    options,
  )
}

export const getUpdateResourceMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateResource>>,
    TError,
    {id: string; data: BodyType<Resource>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateResource>>,
  TError,
  {id: string; data: BodyType<Resource>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateResource>>,
    {id: string; data: BodyType<Resource>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateResource(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateResourceMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateResource>>
>
export type UpdateResourceMutationBody = BodyType<Resource>
export type UpdateResourceMutationError = ErrorType<void>

/**
 * @summary Update a resource
 */
export const useUpdateResource = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateResource>>,
    TError,
    {id: string; data: BodyType<Resource>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateResource>>,
  TError,
  {id: string; data: BodyType<Resource>},
  TContext
> => {
  const mutationOptions = getUpdateResourceMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a resource by its ID
 * @summary Delete a resource
 */
export const deleteResource = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/resources/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteResourceMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteResource>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteResource>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteResource>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteResource(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteResourceMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteResource>>
>

export type DeleteResourceMutationError = ErrorType<void>

/**
 * @summary Delete a resource
 */
export const useDeleteResource = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteResource>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteResource>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteResourceMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all resources
 * @summary Get all resources
 */
export const getAllResources = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Resource[]>(
    {url: `/resources`, method: 'GET', signal},
    options,
  )
}

export const getGetAllResourcesQueryKey = () => {
  return [`/resources`] as const
}

export const getGetAllResourcesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllResources>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllResources>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllResourcesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllResources>>> = ({
    signal,
  }) => getAllResources(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllResources>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllResourcesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllResources>>
>
export type GetAllResourcesQueryError = ErrorType<unknown>

/**
 * @summary Get all resources
 */
export const useGetAllResources = <
  TData = Awaited<ReturnType<typeof getAllResources>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllResources>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllResourcesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllResourcesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllResources>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllResources>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllResourcesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllResources>>> = ({
    signal,
  }) => getAllResources(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllResources>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllResourcesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllResources>>
>
export type GetAllResourcesSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all resources
 */
export const useGetAllResourcesSuspense = <
  TData = Awaited<ReturnType<typeof getAllResources>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllResources>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllResourcesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new resource with the provided data
 * @summary Create a new resource
 */
export const createResource = (
  resource: BodyType<Resource>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Resource>(
    {
      url: `/resources`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: resource,
    },
    options,
  )
}

export const getCreateResourceMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createResource>>,
    TError,
    {data: BodyType<Resource>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createResource>>,
  TError,
  {data: BodyType<Resource>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createResource>>,
    {data: BodyType<Resource>}
  > = (props) => {
    const {data} = props ?? {}

    return createResource(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateResourceMutationResult = NonNullable<
  Awaited<ReturnType<typeof createResource>>
>
export type CreateResourceMutationBody = BodyType<Resource>
export type CreateResourceMutationError = ErrorType<unknown>

/**
 * @summary Create a new resource
 */
export const useCreateResource = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createResource>>,
    TError,
    {data: BodyType<Resource>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createResource>>,
  TError,
  {data: BodyType<Resource>},
  TContext
> => {
  const mutationOptions = getCreateResourceMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a role by its ID
 * @summary Get role by ID
 */
export const getRoleById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Role>(
    {url: `/roles/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetRoleByIdQueryKey = (id: string) => {
  return [`/roles/${id}`] as const
}

export const getGetRoleByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoleById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoleById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetRoleByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleById>>> = ({
    signal,
  }) => getRoleById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getRoleById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetRoleByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoleById>>
>
export type GetRoleByIdQueryError = ErrorType<void>

/**
 * @summary Get role by ID
 */
export const useGetRoleById = <
  TData = Awaited<ReturnType<typeof getRoleById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getRoleById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetRoleByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetRoleByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getRoleById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoleById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetRoleByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRoleById>>> = ({
    signal,
  }) => getRoleById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getRoleById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetRoleByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRoleById>>
>
export type GetRoleByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get role by ID
 */
export const useGetRoleByIdSuspense = <
  TData = Awaited<ReturnType<typeof getRoleById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getRoleById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetRoleByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a role by its ID
 * @summary Update a role
 */
export const updateRole = (
  id: string,
  role: BodyType<Role>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Role>(
    {
      url: `/roles/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: role,
    },
    options,
  )
}

export const getUpdateRoleMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRole>>,
    TError,
    {id: string; data: BodyType<Role>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateRole>>,
  TError,
  {id: string; data: BodyType<Role>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateRole>>,
    {id: string; data: BodyType<Role>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateRole(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateRole>>
>
export type UpdateRoleMutationBody = BodyType<Role>
export type UpdateRoleMutationError = ErrorType<void>

/**
 * @summary Update a role
 */
export const useUpdateRole = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateRole>>,
    TError,
    {id: string; data: BodyType<Role>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateRole>>,
  TError,
  {id: string; data: BodyType<Role>},
  TContext
> => {
  const mutationOptions = getUpdateRoleMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a role by its ID
 * @summary Delete a role
 */
export const deleteRole = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>({url: `/roles/${id}`, method: 'DELETE'}, options)
}

export const getDeleteRoleMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRole>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteRole>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteRole>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteRole(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteRole>>
>

export type DeleteRoleMutationError = ErrorType<void>

/**
 * @summary Delete a role
 */
export const useDeleteRole = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteRole>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteRole>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteRoleMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all roles
 * @summary Get all roles
 */
export const getAllRoles = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Role[]>({url: `/roles`, method: 'GET', signal}, options)
}

export const getGetAllRolesQueryKey = () => {
  return [`/roles`] as const
}

export const getGetAllRolesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllRoles>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllRoles>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllRolesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllRoles>>> = ({
    signal,
  }) => getAllRoles(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllRoles>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllRolesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllRoles>>
>
export type GetAllRolesQueryError = ErrorType<unknown>

/**
 * @summary Get all roles
 */
export const useGetAllRoles = <
  TData = Awaited<ReturnType<typeof getAllRoles>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllRoles>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllRolesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllRolesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllRoles>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllRoles>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllRolesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllRoles>>> = ({
    signal,
  }) => getAllRoles(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllRoles>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllRolesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllRoles>>
>
export type GetAllRolesSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all roles
 */
export const useGetAllRolesSuspense = <
  TData = Awaited<ReturnType<typeof getAllRoles>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllRoles>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllRolesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new role with the provided data
 * @summary Create a new role
 */
export const createRole = (
  role: BodyType<Role>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Role>(
    {
      url: `/roles`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: role,
    },
    options,
  )
}

export const getCreateRoleMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createRole>>,
    TError,
    {data: BodyType<Role>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createRole>>,
  TError,
  {data: BodyType<Role>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createRole>>,
    {data: BodyType<Role>}
  > = (props) => {
    const {data} = props ?? {}

    return createRole(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateRoleMutationResult = NonNullable<
  Awaited<ReturnType<typeof createRole>>
>
export type CreateRoleMutationBody = BodyType<Role>
export type CreateRoleMutationError = ErrorType<unknown>

/**
 * @summary Create a new role
 */
export const useCreateRole = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createRole>>,
    TError,
    {data: BodyType<Role>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createRole>>,
  TError,
  {data: BodyType<Role>},
  TContext
> => {
  const mutationOptions = getCreateRoleMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a task by its ID
 * @summary Get task by ID
 */
export const getTaskById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Task>(
    {url: `/tasks/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetTaskByIdQueryKey = (id: string) => {
  return [`/tasks/${id}`] as const
}

export const getGetTaskByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getTaskById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTaskById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTaskByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTaskById>>> = ({
    signal,
  }) => getTaskById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getTaskById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetTaskByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTaskById>>
>
export type GetTaskByIdQueryError = ErrorType<void>

/**
 * @summary Get task by ID
 */
export const useGetTaskById = <
  TData = Awaited<ReturnType<typeof getTaskById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getTaskById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetTaskByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetTaskByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTaskById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTaskById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetTaskByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getTaskById>>> = ({
    signal,
  }) => getTaskById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTaskById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetTaskByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTaskById>>
>
export type GetTaskByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get task by ID
 */
export const useGetTaskByIdSuspense = <
  TData = Awaited<ReturnType<typeof getTaskById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTaskById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetTaskByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a task by its ID
 * @summary Update a task
 */
export const updateTask = (
  id: string,
  task: BodyType<Task>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Task>(
    {
      url: `/tasks/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: task,
    },
    options,
  )
}

export const getUpdateTaskMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTask>>,
    TError,
    {id: string; data: BodyType<Task>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTask>>,
  TError,
  {id: string; data: BodyType<Task>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTask>>,
    {id: string; data: BodyType<Task>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateTask(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTask>>
>
export type UpdateTaskMutationBody = BodyType<Task>
export type UpdateTaskMutationError = ErrorType<void>

/**
 * @summary Update a task
 */
export const useUpdateTask = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTask>>,
    TError,
    {id: string; data: BodyType<Task>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateTask>>,
  TError,
  {id: string; data: BodyType<Task>},
  TContext
> => {
  const mutationOptions = getUpdateTaskMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a task by its ID
 * @summary Delete a task
 */
export const deleteTask = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>({url: `/tasks/${id}`, method: 'DELETE'}, options)
}

export const getDeleteTaskMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTask>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTask>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTask>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteTask(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTask>>
>

export type DeleteTaskMutationError = ErrorType<void>

/**
 * @summary Delete a task
 */
export const useDeleteTask = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTask>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteTask>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteTaskMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all tasks
 * @summary Get all tasks
 */
export const getAllTasks = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Task[]>({url: `/tasks`, method: 'GET', signal}, options)
}

export const getGetAllTasksQueryKey = () => {
  return [`/tasks`] as const
}

export const getGetAllTasksQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllTasks>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllTasks>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllTasksQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTasks>>> = ({
    signal,
  }) => getAllTasks(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllTasks>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllTasksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllTasks>>
>
export type GetAllTasksQueryError = ErrorType<unknown>

/**
 * @summary Get all tasks
 */
export const useGetAllTasks = <
  TData = Awaited<ReturnType<typeof getAllTasks>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllTasks>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllTasksQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllTasksSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllTasks>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllTasks>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllTasksQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllTasks>>> = ({
    signal,
  }) => getAllTasks(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllTasks>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllTasksSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllTasks>>
>
export type GetAllTasksSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all tasks
 */
export const useGetAllTasksSuspense = <
  TData = Awaited<ReturnType<typeof getAllTasks>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllTasks>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllTasksSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new task with the provided data
 * @summary Create a new task
 */
export const createTask = (
  task: BodyType<Task>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Task>(
    {
      url: `/tasks`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: task,
    },
    options,
  )
}

export const getCreateTaskMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTask>>,
    TError,
    {data: BodyType<Task>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTask>>,
  TError,
  {data: BodyType<Task>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTask>>,
    {data: BodyType<Task>}
  > = (props) => {
    const {data} = props ?? {}

    return createTask(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateTaskMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTask>>
>
export type CreateTaskMutationBody = BodyType<Task>
export type CreateTaskMutationError = ErrorType<unknown>

/**
 * @summary Create a new task
 */
export const useCreateTask = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTask>>,
    TError,
    {data: BodyType<Task>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createTask>>,
  TError,
  {data: BodyType<Task>},
  TContext
> => {
  const mutationOptions = getCreateTaskMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a timeCard employee by its ID
 * @summary Get timeCard employee by ID
 */
export const getTimeCardEmployeeById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<TimeCardEmployee>(
    {url: `/timeCardEmployees/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetTimeCardEmployeeByIdQueryKey = (id: string) => {
  return [`/timeCardEmployees/${id}`] as const
}

export const getGetTimeCardEmployeeByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimeCardEmployeeById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeCardEmployeeById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetTimeCardEmployeeByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTimeCardEmployeeById>>
  > = ({signal}) => getTimeCardEmployeeById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getTimeCardEmployeeById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetTimeCardEmployeeByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimeCardEmployeeById>>
>
export type GetTimeCardEmployeeByIdQueryError = ErrorType<void>

/**
 * @summary Get timeCard employee by ID
 */
export const useGetTimeCardEmployeeById = <
  TData = Awaited<ReturnType<typeof getTimeCardEmployeeById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<
        Awaited<ReturnType<typeof getTimeCardEmployeeById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetTimeCardEmployeeByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetTimeCardEmployeeByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getTimeCardEmployeeById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeCardEmployeeById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetTimeCardEmployeeByIdQueryKey(id)

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getTimeCardEmployeeById>>
  > = ({signal}) => getTimeCardEmployeeById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getTimeCardEmployeeById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetTimeCardEmployeeByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getTimeCardEmployeeById>>
>
export type GetTimeCardEmployeeByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get timeCard employee by ID
 */
export const useGetTimeCardEmployeeByIdSuspense = <
  TData = Awaited<ReturnType<typeof getTimeCardEmployeeById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getTimeCardEmployeeById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetTimeCardEmployeeByIdSuspenseQueryOptions(
    id,
    options,
  )

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a timeCard employee by its ID
 * @summary Update a timeCard employee
 */
export const updateTimeCardEmployee = (
  id: string,
  timeCardEmployee: BodyType<TimeCardEmployee>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<TimeCardEmployee>(
    {
      url: `/timeCardEmployees/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: timeCardEmployee,
    },
    options,
  )
}

export const getUpdateTimeCardEmployeeMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTimeCardEmployee>>,
    TError,
    {id: string; data: BodyType<TimeCardEmployee>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateTimeCardEmployee>>,
  TError,
  {id: string; data: BodyType<TimeCardEmployee>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateTimeCardEmployee>>,
    {id: string; data: BodyType<TimeCardEmployee>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateTimeCardEmployee(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateTimeCardEmployeeMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateTimeCardEmployee>>
>
export type UpdateTimeCardEmployeeMutationBody = BodyType<TimeCardEmployee>
export type UpdateTimeCardEmployeeMutationError = ErrorType<void>

/**
 * @summary Update a timeCard employee
 */
export const useUpdateTimeCardEmployee = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateTimeCardEmployee>>,
    TError,
    {id: string; data: BodyType<TimeCardEmployee>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateTimeCardEmployee>>,
  TError,
  {id: string; data: BodyType<TimeCardEmployee>},
  TContext
> => {
  const mutationOptions = getUpdateTimeCardEmployeeMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a timeCard employee by its ID
 * @summary Delete a timeCard employee
 */
export const deleteTimeCardEmployee = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>(
    {url: `/timeCardEmployees/${id}`, method: 'DELETE'},
    options,
  )
}

export const getDeleteTimeCardEmployeeMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTimeCardEmployee>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteTimeCardEmployee>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteTimeCardEmployee>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteTimeCardEmployee(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteTimeCardEmployeeMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteTimeCardEmployee>>
>

export type DeleteTimeCardEmployeeMutationError = ErrorType<void>

/**
 * @summary Delete a timeCard employee
 */
export const useDeleteTimeCardEmployee = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteTimeCardEmployee>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteTimeCardEmployee>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteTimeCardEmployeeMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all timeCard employees
 * @summary Get all timeCard employees
 */
export const getAllTimeCardEmployees = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<TimeCardEmployee[]>(
    {url: `/timeCardEmployees`, method: 'GET', signal},
    options,
  )
}

export const getGetAllTimeCardEmployeesQueryKey = () => {
  return [`/timeCardEmployees`] as const
}

export const getGetAllTimeCardEmployeesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllTimeCardEmployees>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllTimeCardEmployees>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllTimeCardEmployeesQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllTimeCardEmployees>>
  > = ({signal}) => getAllTimeCardEmployees(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllTimeCardEmployees>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllTimeCardEmployeesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllTimeCardEmployees>>
>
export type GetAllTimeCardEmployeesQueryError = ErrorType<unknown>

/**
 * @summary Get all timeCard employees
 */
export const useGetAllTimeCardEmployees = <
  TData = Awaited<ReturnType<typeof getAllTimeCardEmployees>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<
      Awaited<ReturnType<typeof getAllTimeCardEmployees>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllTimeCardEmployeesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllTimeCardEmployeesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllTimeCardEmployees>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllTimeCardEmployees>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey =
    queryOptions?.queryKey ?? getGetAllTimeCardEmployeesQueryKey()

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAllTimeCardEmployees>>
  > = ({signal}) => getAllTimeCardEmployees(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllTimeCardEmployees>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllTimeCardEmployeesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllTimeCardEmployees>>
>
export type GetAllTimeCardEmployeesSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all timeCard employees
 */
export const useGetAllTimeCardEmployeesSuspense = <
  TData = Awaited<ReturnType<typeof getAllTimeCardEmployees>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllTimeCardEmployees>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllTimeCardEmployeesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new timeCard employee with the provided data
 * @summary Create a new timeCard employee
 */
export const createTimeCardEmployee = (
  timeCardEmployee: BodyType<TimeCardEmployee>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<TimeCardEmployee>(
    {
      url: `/timeCardEmployees`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: timeCardEmployee,
    },
    options,
  )
}

export const getCreateTimeCardEmployeeMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTimeCardEmployee>>,
    TError,
    {data: BodyType<TimeCardEmployee>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createTimeCardEmployee>>,
  TError,
  {data: BodyType<TimeCardEmployee>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createTimeCardEmployee>>,
    {data: BodyType<TimeCardEmployee>}
  > = (props) => {
    const {data} = props ?? {}

    return createTimeCardEmployee(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateTimeCardEmployeeMutationResult = NonNullable<
  Awaited<ReturnType<typeof createTimeCardEmployee>>
>
export type CreateTimeCardEmployeeMutationBody = BodyType<TimeCardEmployee>
export type CreateTimeCardEmployeeMutationError = ErrorType<unknown>

/**
 * @summary Create a new timeCard employee
 */
export const useCreateTimeCardEmployee = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createTimeCardEmployee>>,
    TError,
    {data: BodyType<TimeCardEmployee>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createTimeCardEmployee>>,
  TError,
  {data: BodyType<TimeCardEmployee>},
  TContext
> => {
  const mutationOptions = getCreateTimeCardEmployeeMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a list of all users
 * @summary Get all users
 */
export const getAllUsers = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<User[]>({url: `/users`, method: 'GET', signal}, options)
}

export const getGetAllUsersQueryKey = () => {
  return [`/users`] as const
}

export const getGetAllUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsers>>> = ({
    signal,
  }) => getAllUsers(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllUsers>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllUsers>>
>
export type GetAllUsersQueryError = ErrorType<unknown>

/**
 * @summary Get all users
 */
export const useGetAllUsers = <
  TData = Awaited<ReturnType<typeof getAllUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllUsers>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllUsersQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllUsersSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllUsers>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllUsers>>> = ({
    signal,
  }) => getAllUsers(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllUsers>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllUsersSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllUsers>>
>
export type GetAllUsersSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all users
 */
export const useGetAllUsersSuspense = <
  TData = Awaited<ReturnType<typeof getAllUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllUsers>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllUsersSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new user with the provided data
 * @summary Create a new user
 */
export const createUser = (
  user: BodyType<User>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<User>(
    {
      url: `/users`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: user,
    },
    options,
  )
}

export const getCreateUserMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    {data: BodyType<User>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  {data: BodyType<User>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUser>>,
    {data: BodyType<User>}
  > = (props) => {
    const {data} = props ?? {}

    return createUser(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUser>>
>
export type CreateUserMutationBody = BodyType<User>
export type CreateUserMutationError = ErrorType<unknown>

/**
 * @summary Create a new user
 */
export const useCreateUser = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    {data: BodyType<User>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  {data: BodyType<User>},
  TContext
> => {
  const mutationOptions = getCreateUserMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a user by its ID
 * @summary Get user by ID
 */
export const getUserById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<User>(
    {url: `/users/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetUserByIdQueryKey = (id: string) => {
  return [`/users/${id}`] as const
}

export const getGetUserByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({
    signal,
  }) => getUserById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getUserById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetUserByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserById>>
>
export type GetUserByIdQueryError = ErrorType<void>

/**
 * @summary Get user by ID
 */
export const useGetUserById = <
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getUserById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetUserByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetUserByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserById>>> = ({
    signal,
  }) => getUserById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getUserById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetUserByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserById>>
>
export type GetUserByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get user by ID
 */
export const useGetUserByIdSuspense = <
  TData = Awaited<ReturnType<typeof getUserById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getUserById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetUserByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a user by its ID
 * @summary Update a user
 */
export const updateUser = (
  id: string,
  user: BodyType<User>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<User>(
    {
      url: `/users/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: user,
    },
    options,
  )
}

export const getUpdateUserMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    {id: string; data: BodyType<User>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  {id: string; data: BodyType<User>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    {id: string; data: BodyType<User>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateUser(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateUser>>
>
export type UpdateUserMutationBody = BodyType<User>
export type UpdateUserMutationError = ErrorType<void>

/**
 * @summary Update a user
 */
export const useUpdateUser = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    {id: string; data: BodyType<User>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  {id: string; data: BodyType<User>},
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a user by its ID
 * @summary Delete a user
 */
export const deleteUser = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>({url: `/users/${id}`, method: 'DELETE'}, options)
}

export const getDeleteUserMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteUser(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteUserMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteUser>>
>

export type DeleteUserMutationError = ErrorType<void>

/**
 * @summary Delete a user
 */
export const useDeleteUser = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteUserMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a user by its Token
 * @summary Get user info by Token
 */
export const getUser = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<User>({url: `/me`, method: 'GET', signal}, options)
}

export const getGetUserQueryKey = () => {
  return [`/me`] as const
}

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>
export type GetUserQueryError = ErrorType<void>

/**
 * @summary Get user info by Token
 */
export const useGetUser = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetUserQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetUserSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getUser>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetUserSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>
export type GetUserSuspenseQueryError = ErrorType<void>

/**
 * @summary Get user info by Token
 */
export const useGetUserSuspense = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = ErrorType<void>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetUserSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieve a list of users currently online
 * @summary Get online users
 */
export const getOnlineUsers = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<User[]>(
    {url: `/online-users`, method: 'GET', signal},
    options,
  )
}

export const getGetOnlineUsersQueryKey = () => {
  return [`/online-users`] as const
}

export const getGetOnlineUsersQueryOptions = <
  TData = Awaited<ReturnType<typeof getOnlineUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getOnlineUsers>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOnlineUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOnlineUsers>>> = ({
    signal,
  }) => getOnlineUsers(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getOnlineUsers>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetOnlineUsersQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOnlineUsers>>
>
export type GetOnlineUsersQueryError = ErrorType<unknown>

/**
 * @summary Get online users
 */
export const useGetOnlineUsers = <
  TData = Awaited<ReturnType<typeof getOnlineUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getOnlineUsers>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetOnlineUsersQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetOnlineUsersSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getOnlineUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getOnlineUsers>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetOnlineUsersQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getOnlineUsers>>> = ({
    signal,
  }) => getOnlineUsers(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getOnlineUsers>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetOnlineUsersSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getOnlineUsers>>
>
export type GetOnlineUsersSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get online users
 */
export const useGetOnlineUsersSuspense = <
  TData = Awaited<ReturnType<typeof getOnlineUsers>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getOnlineUsers>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetOnlineUsersSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Retrieve a list of all zones
 * @summary Get all zones
 */
export const getAllZones = (
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Zone[]>({url: `/zones`, method: 'GET', signal}, options)
}

export const getGetAllZonesQueryKey = () => {
  return [`/zones`] as const
}

export const getGetAllZonesQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllZones>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllZones>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllZonesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllZones>>> = ({
    signal,
  }) => getAllZones(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getAllZones>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllZonesQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllZones>>
>
export type GetAllZonesQueryError = ErrorType<unknown>

/**
 * @summary Get all zones
 */
export const useGetAllZones = <
  TData = Awaited<ReturnType<typeof getAllZones>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseQueryOptions<Awaited<ReturnType<typeof getAllZones>>, TError, TData>
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllZonesQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetAllZonesSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getAllZones>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllZones>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetAllZonesQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAllZones>>> = ({
    signal,
  }) => getAllZones(requestOptions, signal)

  return {queryKey, queryFn, ...queryOptions} as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getAllZones>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetAllZonesSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAllZones>>
>
export type GetAllZonesSuspenseQueryError = ErrorType<unknown>

/**
 * @summary Get all zones
 */
export const useGetAllZonesSuspense = <
  TData = Awaited<ReturnType<typeof getAllZones>>,
  TError = ErrorType<unknown>,
>(options?: {
  query?: Partial<
    UseSuspenseQueryOptions<
      Awaited<ReturnType<typeof getAllZones>>,
      TError,
      TData
    >
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetAllZonesSuspenseQueryOptions(options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Create a new zone with the provided data
 * @summary Create a new zone
 */
export const createZone = (
  zone: BodyType<Zone>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Zone>(
    {
      url: `/zones`,
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      data: zone,
    },
    options,
  )
}

export const getCreateZoneMutationOptions = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createZone>>,
    TError,
    {data: BodyType<Zone>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof createZone>>,
  TError,
  {data: BodyType<Zone>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createZone>>,
    {data: BodyType<Zone>}
  > = (props) => {
    const {data} = props ?? {}

    return createZone(data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type CreateZoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof createZone>>
>
export type CreateZoneMutationBody = BodyType<Zone>
export type CreateZoneMutationError = ErrorType<unknown>

/**
 * @summary Create a new zone
 */
export const useCreateZone = <
  TError = ErrorType<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createZone>>,
    TError,
    {data: BodyType<Zone>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof createZone>>,
  TError,
  {data: BodyType<Zone>},
  TContext
> => {
  const mutationOptions = getCreateZoneMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Retrieve a zone by its ID
 * @summary Get zone by ID
 */
export const getZoneById = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
  signal?: AbortSignal,
) => {
  return axiosInstance<Zone>(
    {url: `/zones/${id}`, method: 'GET', signal},
    options,
  )
}

export const getGetZoneByIdQueryKey = (id: string) => {
  return [`/zones/${id}`] as const
}

export const getGetZoneByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getZoneById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getZoneById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetZoneByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getZoneById>>> = ({
    signal,
  }) => getZoneById(id, requestOptions, signal)

  return {queryKey, queryFn, enabled: !!id, ...queryOptions} as UseQueryOptions<
    Awaited<ReturnType<typeof getZoneById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetZoneByIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof getZoneById>>
>
export type GetZoneByIdQueryError = ErrorType<void>

/**
 * @summary Get zone by ID
 */
export const useGetZoneById = <
  TData = Awaited<ReturnType<typeof getZoneById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getZoneById>>, TError, TData>
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetZoneByIdQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey
  }

  query.queryKey = queryOptions.queryKey

  return query
}

export const getGetZoneByIdSuspenseQueryOptions = <
  TData = Awaited<ReturnType<typeof getZoneById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getZoneById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
) => {
  const {query: queryOptions, request: requestOptions} = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getGetZoneByIdQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getZoneById>>> = ({
    signal,
  }) => getZoneById(id, requestOptions, signal)

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseSuspenseQueryOptions<
    Awaited<ReturnType<typeof getZoneById>>,
    TError,
    TData
  > & {queryKey: QueryKey}
}

export type GetZoneByIdSuspenseQueryResult = NonNullable<
  Awaited<ReturnType<typeof getZoneById>>
>
export type GetZoneByIdSuspenseQueryError = ErrorType<void>

/**
 * @summary Get zone by ID
 */
export const useGetZoneByIdSuspense = <
  TData = Awaited<ReturnType<typeof getZoneById>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<
      UseSuspenseQueryOptions<
        Awaited<ReturnType<typeof getZoneById>>,
        TError,
        TData
      >
    >
    request?: SecondParameter<typeof axiosInstance>
  },
): UseSuspenseQueryResult<TData, TError> & {queryKey: QueryKey} => {
  const queryOptions = getGetZoneByIdSuspenseQueryOptions(id, options)

  const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
    TData,
    TError
  > & {queryKey: QueryKey}

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Update a zone by its ID
 * @summary Update a zone
 */
export const updateZone = (
  id: string,
  zone: BodyType<Zone>,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<Zone>(
    {
      url: `/zones/${id}`,
      method: 'PUT',
      headers: {'Content-Type': 'application/json'},
      data: zone,
    },
    options,
  )
}

export const getUpdateZoneMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateZone>>,
    TError,
    {id: string; data: BodyType<Zone>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateZone>>,
  TError,
  {id: string; data: BodyType<Zone>},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateZone>>,
    {id: string; data: BodyType<Zone>}
  > = (props) => {
    const {id, data} = props ?? {}

    return updateZone(id, data, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type UpdateZoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof updateZone>>
>
export type UpdateZoneMutationBody = BodyType<Zone>
export type UpdateZoneMutationError = ErrorType<void>

/**
 * @summary Update a zone
 */
export const useUpdateZone = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateZone>>,
    TError,
    {id: string; data: BodyType<Zone>},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof updateZone>>,
  TError,
  {id: string; data: BodyType<Zone>},
  TContext
> => {
  const mutationOptions = getUpdateZoneMutationOptions(options)

  return useMutation(mutationOptions)
}

/**
 * Delete a zone by its ID
 * @summary Delete a zone
 */
export const deleteZone = (
  id: string,
  options?: SecondParameter<typeof axiosInstance>,
) => {
  return axiosInstance<void>({url: `/zones/${id}`, method: 'DELETE'}, options)
}

export const getDeleteZoneMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteZone>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteZone>>,
  TError,
  {id: string},
  TContext
> => {
  const {mutation: mutationOptions, request: requestOptions} = options ?? {}

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteZone>>,
    {id: string}
  > = (props) => {
    const {id} = props ?? {}

    return deleteZone(id, requestOptions)
  }

  return {mutationFn, ...mutationOptions}
}

export type DeleteZoneMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteZone>>
>

export type DeleteZoneMutationError = ErrorType<void>

/**
 * @summary Delete a zone
 */
export const useDeleteZone = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteZone>>,
    TError,
    {id: string},
    TContext
  >
  request?: SecondParameter<typeof axiosInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteZone>>,
  TError,
  {id: string},
  TContext
> => {
  const mutationOptions = getDeleteZoneMutationOptions(options)

  return useMutation(mutationOptions)
}
